# Προετοιμασία για τις εξετάσεις στο μάθημα «Αντικειμενοστραφής Προγραμματισμός» με τη C++

Θα πρέπει να είστε σε θέση να:
* κατανοείτε τη χρήση των δεικτών
* κάνετε δέσμευση και αποδέσμευση μνήμης
* κατανοείτε τον ορισμό και την χρήση πινάκων
* γράφετε συναρτήσεις
* κατανοείτε τη διαφορά ανάμεσα στην κλήση με τιμή και στην κλήση με αναφορά
* κατανοείτε τη χρήση των αναφορών
* γράφετε κλάσεις και να δημιουργείτε αντικείμενα των κλάσεων
* ορίζετε κατασκευαστές και καταστροφείς
* κατανοείτε τη χρήση του const
* ορίζετε υπερφορτωμένους τελεστές
* χρησιμοποιείτε την κληρονομικότητα
* κατανοείτε την έννοια των αφηρημένων κλάσεων
* ορίζετε πολυμορφικές ιεραρχίες
* προγραμματίζετε με πρότυπα (template programming)
* χρησιμοποιείτε λάμδα συναρτήσεις
* χρησιμοποιείτε STL περιέκτες
* χρησιμοποιείτε STL επαναλήπτες
* χρησιμοποιείτε STL αλγορίθμους
* διαβάζετε απλά διαγράμματα κλάσεων UML και να τα μετατρέπετε σε C++ κώδικα
* κατανοείτε τις βασικές διαφορές της C++ από την Java

## Γνώσεις που θα χρειαστείτε από τη C 

* Δείκτες (dereference=αποαναφορά, διευθύνσεις)

    Τι θα εμφανίσει ο ακόλουθος κώδικας κατά την εκτέλεσή του;

    ```
    int a, b, c;
    int *x = &a, *y = &b;

    *x = 42;
    *y = 52;
    a++;
    b -= 2;
    *x += a;
    y = &c;
    *y = *x + b;

    cout << a << endl;
    cout << b << endl;
    cout << c << endl;
    cout << *x << endl;
    cout << *y << endl;
    cout << (x == &a) << endl;
    cout << (x == &b) << endl;
    cout << (x == &c) << endl;
    ```

    *   [pointers1.cpp](./pointers1.cpp)

* Κλήση με τιμή και κλήση με αναφορά με χρήση δεικτών

    Γράψτε μια συνάρτηση με όνομα circle που να δέχεται μια παράμετρο που να αντιστοιχεί στην ακτίνα ενός κύκλου και να επιστρέφει το εμβαδόν του κύκλου και την περίμετρο του κύκλου.

    * [call_by_reference1.cpp](./call_by_reference1.cpp)
    * [call_by_reference2.cpp](./call_by_reference2.cpp) εναλλακτικά με references της C++

* Δέσμευση, αποδέσμευση μνήμης (malloc, free)

    Γράψτε πρόγραμμα που να δεσμεύει θέσεις μνήμης για μια ακέραια, μια πραγματική (double) και μια τιμή χαρακτήρα, να αναθέτει μια τιμή σε κάθε δεσμευμένη θέση μνήμης και να απελευθερώνει τη μνήμη

    * [dynamic_memory1.cpp](./dynamic_memory1.cpp)
    * [dynamic_memory2.cpp](./dynamic_memory2.cpp) εναλλακτικά με new, delete της C++

* Στατικοί, δυναμικοί πίνακες

    Γράψτε πρόγραμμα που να δημιουργεί έναν πίνακα 5 θέσεων με τις τιμές {2,7,1,3,6}. Να δέχεται από τον χρήστη μια ακέραια τιμή x και να αντιγράφει τον πίνακα x φορές σε έναν δυναμικό πίνακα τον οποίο στην συνέχεια να εμφανίζει στην οθόνη. Να αποδεσμεύει τον πίνακα πριν τον τερματισμό του προγράμματος

    * [static_dynamic_arrays1.cpp](./static_dynamic_arrays1.cpp)
    * [static_dynamic_arrays2.cpp](./static_dynamic_arrays2.cpp) εναλλακτικά με new, delete της C++

* Δισδιάστατοι πίνακες

    Γράψτε πρόγραμμα που να δημιουργεί έναν πίνακα 5x5 που σε κάθε στοιχείο του να έχει ως τιμή το άθροισμα των δεικτών του στοιχείου (π.χ. στο στοιχείο a[2][3] να έχει την τιμή 2+3=5). Εμφανίστε τον πίνακα.

    * [two_dimensional_array1.cpp](./two_dimensional_array1.cpp)

* enums

    Δημιουργήστε ένα enumeration με τιμές ΟΝ και OFF. Γράψτε ένα πρόγραμμα που να ορίζει έναν πίνακα με 5 τιμές ΟΝ ή OFF. Μετρήστε πόσα είναι τα ON και εμφανίστε το αποτέλεσμα.

    * [enum1.cpp](./enum1.cpp)
    * [enum2.cpp](./enum2.cpp) εναλλακτικά με enum classes της C++
  

* Casting

    Τι θα εμφανίσει ο ακόλουθος κώδικας;

    ```
    int a=10,b=3;
    double c;

    c= a/b;
    cout << c << endl;
    c=(double)a/b;
    cout << c << endl;
    c=(double)a/(double)b;
    a = c;
    cout << a << endl;
    ```

    * [casting1.cpp](./casting1.cpp)
    * [casting2.cpp](./casting2.cpp) εναλλακτικά με static_cast της C++

* inline συναρτήσεις

    Γράψτε ένα πρόγραμμα που να δημιουργεί ένα σύνολο από 10 σημεία στο καρτεσιανό επίπεδο. Γράψτε μια συνάρτηση distance που να επιστρέφει την απόσταση δύο σημείων. Ορίστε τη συνάρτηση ως inline και εντοπίστε τα σημεία που απέχουν τη μικρότερη απόσταση.

    * [inline1.cpp](./inline1.cpp)

* Χωριστή μεταγλώττιση

    Για τη δευτεροβάθμια εξίσωση: ax^2+bx+c=0
    Γράψτε μια συνάρτηση που να υπολογίζει τη διακρίνουσα. Γράψτε μια συνάρτηση που να επιστρέφει τις ρίζες της δευτεροβάθμιας εξίσωσης καθώς και μια τιμή (1 ή 0) που να υποδηλώνει το εάν υπάρχουν πραγματικές ρίζες ή όχι.

    * [quadratic_single_file.cpp](./quadratic_single_file.cpp)

    Γράψτε  ξεχωριστά header και source αρχεία (quadratic.hpp, quadratic.cpp) καθώς και ένα πρόγραμμα οδήγησης (quadratic_main.cpp). Δώστε τις εντολές μεταγλώττισης και εκτέλεσης του προγράμματος.

    * [quadratic.hpp](./quadratic.hpp)
    * [quadratic.cpp](./quadratic.cpp)
    * [quadratic_main.cpp](./quadratic_main.cpp)

    Μεταγλώττιση:

    $ g++ quadratic.cpp quadratic_main.cpp -o quadratic

## C++

* Δέσμευση, αποδέσμευση μνήμης (new, delete)

    Γράψτε πρόγραμμα που να δεσμεύει θέσεις μνήμης για μια ακέραια, μια πραγματική (double) και μια τιμή χαρακτήρα, να αναθέτει μια τιμή σε κάθε δεσμευμένη θέση μνήμης και να απελευθερώνει τη μνήμη

    * [dynamic_memory2.cpp](./dynamic_memory2.cpp)

* Χώροι ονομάτων (namespaces)

    Ορίστε ένα namespace uoi και μέσα σε αυτό ένα άλλο namespace dit. Ορίστε 3 συναρτήσεις με όνομα fun στο global, στο uoi και στο dit namespace. Στη main καλέστε και τις 3 συναρτήσεις fun.

    * [namespace1.cpp](./namespace1.cpp)

* enum classes

    Δημιουργήστε ένα enumeration class με τιμές ΟΝ και OFF. Γράψτε ένα πρόγραμμα που να ορίζει έναν πίνακα με 5 τιμές ΟΝ ή OFF. Μετρήστε πόσα είναι τα ON και εμφανίστε το αποτέλεσμα.

    * [enum2.cpp](./enum2.cpp)

* Αναφορές (references)

    Τι θα εμφανίσει ο ακόλουθος κώδικας;

    ```
    int a = 2;
    int &r = a;
    a += 2;
    r *= 2;
    cout << a << endl;
    cout << r << endl;
    ```

    * [reference1.cpp](./reference1.cpp)

* Πέρασμα με τιμή, πέρασμα με αναφορά με χρήση αναφορών

    Γράψτε μια συνάρτηση με όνομα circle που να δέχεται μια παράμετρο που να αντιστοιχεί στην ακτίνα ενός κύκλου και να επιστρέφει το εμβαδόν του κύκλου και την περίμετρο του κύκλου.

    * [call_by_reference2.cpp](./call_by_reference2.cpp)

* Χρήση του const

    Γράψτε ένα πρόγραμμα που να κάνει 3 διαφορετικές χρήσεις του const. Προσθέστε σχόλια για τη διαφορετική σημασία του const στην κάθε περίπτωση.

    * [const1.cpp](./const1.cpp)

* Ορισμός κλάσεων (private/public members)

    Γράψτε ένα πρόγραμμα που να ορίζει μια κλάση Α με ένα ακέραιο ιδιωτικό μέλος δεδομένων x και ένα ακέραιο δημόσιο μέλος δεδομένων y. Συμπληρώστε τον απαιτούμενο κώδικα έτσι ώστε για ένα αντικείμενο που δημιουργείται στη main να εμφανίζεται τόσο η τιμή του x όσο και η τιμή του y.

    * [class1.cpp](./class1.cpp)

* Κατασκευαστές (προκαθορισμένος, υπερφόρτωση, default παράμετροι)

    Γράψτε ένα πρόγραμμα που να ορίζει μια κλάση Α με δύο ακέραια ιδιωτικά μέλη δεδομένων x και y. Ορίστε 2 διαφορετικούς κατασκευαστές κάνοντας χρήση και προκαθορισμένης τιμής για την παράμετρο ενός κατασκευαστή. Στη main δημιουργείστε 1 αντικείμενο με τον προκαθορισμένο κατασκευαστή και 1 πίνακα 5 αντικειμένων με το δεύτερο κατασκευαστή.

    * [constructor1.cpp](./constructor1.cpp)

* Κατασκευαστής αντιγραφής (shallow copy/deep copy)

    Γράψτε ένα πρόγραμμα που να ορίζει μια κλάση Α με ένα ιδιωτικό μέλος δεδομένων που να είναι δείκτης προς πίνακα ακεραίων. Συμπληρώστε έναν κατασκευαστή αντιγραφής. Χρησιμοποιήστε τον κατασκευαστή αντιγραφής στη main.

    * [deep_copy1.cpp](./deep_copy1.cpp)

* Τελεστής ανάθεσης (assignment operator)

    Γράψτε ένα πρόγραμμα που να ορίζει μια κλάση Α με ένα ιδιωτικό μέλος δεδομένων που να είναι δείκτης προς πίνακα ακεραίων. Συμπληρώστε έναν τελεστή ανάθεσης. Χρησιμοποιήστε τον τελεστή ανάθεσης στη main.

    * [assignment_operator1.cpp](./assignment_operator1.cpp)

* Καταστροφείς

    Ορίστε τον καταστροφέα μιας κλάσης έτσι ώστε να εμφανίζει τη θέση μνήμης του αντικειμένου και το μέγεθος του αντικειμένου που καταστρέφεται. Στη main προκαλέστε διαδοχικά για 10 φορές σε μια for την κλήση του καταστροφέα

    * [destructor1.cpp](./destructor1.cpp)

* Στατικά μέλη κλάσεων

    Δημιουργήστε μια κλάση που να περιέχει ένα στατικό μέλος δεδομένων που να καταμετρά όλα τα αντικείμενα της κλάσης που είναι ενεργά. Επιπλέον, δημιουργήστε μια στατική συνάρτηση μέλος που να εμφανίζει το όνομα της κλάσης. 

    * [static1.cpp](./static1.cpp)

* Φίλες συναρτήσεις

    Δημιουργήστε μια κλάση Α με ένα ακέραιο ιδιωτικό μέλος x. Συμπληρώστε μια φίλη συνάρτηση fun που να εκτυπώνει την τιμή του x για ένα αντικείμενο της κλάσης Α.

    * [friend1.cpp](./friend1.cpp)

* Φίλες κλάσεις

    Δημιουργήστε μια κλάση Α με ένα ακέραιο ιδιωτικό μέλος x. Συμπληρώστε μια φίλη κλάση Β που να εκτυπώνει την τιμή του x για ένα αντικείμενο της κλάσης Α.

    * [friend2.cpp](./friend2.cpp)

* Υπερφόρτωση τελεστών (+, <, ==, « , »)

    Δημιουργήστε μια κλάση Α με τρία ακέραια ιδιωτικά μέλη. Υπερφορτώστε τον τελεστή < έτσι ώστε η σύγκριση αντικειμένων να γίνεται με βάση το άθροισμα των 3 ιδιωτικών μελών. Επιπλέον υπερφορτώστε τον τελεστή << έτσι ώστε να εμφανίζονται τα 3 ιδιωτικά πεδία και το άθροισμά τους.

    * [overload1.cpp](./overload1.cpp) 

<!-- * Εμφωλιασμοί κλάσεων (nested classes)

    Δημιουργήστε μια κλάση Α με ένα ιδιωτικό ακέραιο μέλος δεδομένων x. Εντός της A δημιουργήστε μια φωλιασμένη (nested) κλάση B. Γράψτε μια συνάρτηση fun στην B που να εμφανίζει για ένα αντικείμενο της κλάσης Α το x. Καλέστε τη συνάρτηση fun από τη main.

    * [nested1.cpp](./nested1.cpp) -->

* Μετατροπή αντικειμένου σε λεκτικό

    Δημιουργήστε μια κλάση A με ένα ακέραιο ιδιωτικό μέλος x. Συμπληρώστε την κατάλληλη συνάρτηση έτσι ώστε να μετατρέπεται ένα αντικείμενο της κλάσης Α σε λεκτικό με περιεχόμενο το x.

    * [to_string.cpp](./to_string.cpp)

* Κληρονομικότητα (βασικές κλάσεις, παραγόμενες κλάσεις, το keyword protected)

    Δημιουργήστε ιεραρχία κλάσεων με βασική κλάση την Base και παραγόμενη κλάση την Derived. Ορίστε στην Base ένα ιδιωτικό ακέραιο μέλος δεδομένων x, ένα προστατευμένο ακέραιο μέλος δεδομένων y και ένα δημόσιο ακέραιο μέλος δεδομένων z. Ορίστε ένα ιδιωτικό ακέραιο μέλος δεδομένων w στη Derived. Στη main δημιουργήστε ένα αντικείμενο της Derived και εμφανίστε όλα τα μέλη δεδομένων του αντικειμένου. Συμπληρώστε κατασκευαστές για τις κλάσεις Base και Derived και ότι άλλο χρειάζεται για να επιτευχθεί το ζητούμενο αποτέλεσμα.

    * [inheritance1.cpp](./inheritance1.cpp)

* Κληρονομικότητα (overload, override)

    Δημιουργήστε ιεραρχία κλάσεων με βασική κλάση την Base και παραγόμενη κλάση την Derived. Ορίστε στη Base δύο συναρτήσεις με ονόματα foo και bar. Συμπληρώστε κώδικα έτσι ώστε στη μεν foo να εφαρμόζεται υπερφόρτωση ενώ στην bar να εφαρμόζεται παράκαμψη για τα αντικείμενα της κλάσης Derived. Καλέστε τις συναρτήσεις στη main.

    * [inheritance2.cpp](./inheritance2.cpp)

* Πολυμορφικές ιεραρχίες (virtual συναρτήσεις)

    Δημιουργήστε ιεραρχία κλάσεων με βασική κλάση την Base και παραγόμενες κλάσεις την DerivedA και DerivedB. Ορίστε ένα ακέραιο μέλος δεδομένων στην κλάση Base, ένα επιπλέον ακέραιο μέλος δεδομένων στην κλάση DerivedA και δύο επιπλέον ακέραια μέλη δεδομένων στην κλάση DerivedΒ. Ορίστε μια virtual συνάρτηση get_value στην Base και επαναορίστε την στις παραγόμενες κλάσεις έτσι ώστε να επιστρέφει σε κάθε περίπτωση το άθροισμα των μελών δεδομένων που διαθέτει η κάθε κλάση. Στη main γεμίστε έναν πίνακα με δείκτες προς αντικείμενα και των τριών κλάσεων και καλέστε τη συνάρτηση get_value για κάθε αντικείμενο.

    * [inheritance3.cpp](./inheritance3.cpp)

* αφηρημένες κλάσεις (pure virtual functions)

    Δημιουργήστε ιεραρχία κλάσεων με βασική κλάση την Base και παραγόμενη κλάση την Derived. Ορίστε στη Base δύο συναρτήσεις με ονόματα foo και bar. Ορίστε την foo ως pure virtual. Καλέστε τις συναρτήσεις στη main για ένα αντικείμενο Derived.

    * [inheritance4.cpp](./inheritance4.cpp)

* templates (εφαρμογή σε συναρτήσεις, εφαρμογή σε δομές/κλάσεις)

    Κατασκευάστε μια συνάρτηση που να δέχεται ως παραμέτρους έναν πίνακα και το μέγεθος του και θα επιστρέφει τη μεγαλύτερη τιμή του πίνακα. Ο τύπος των στοιχείων που θα περιέχει ο πίνακας θα ορίζεται κατά την κλήση της συνάρτησης. Πραγματοποιήστε κλήση της συνάρτησης για έναν πίνακα ακεραίων, για έναν πίνακα πραγματικών και για έναν πίνακα λεκτικών.

    * [template1.cpp](./template1.cpp)

    Κατασκευάστε μια templated κλάση Α με templated τύπο T. Ορίστε δύο ιδιωτικά πεδία στην κλάση Α, τύπου Τ, έναν κατασκευαστή που να θέτει τα μέλη δεδομένων και μια συνάρτηση που να εμφανίζει τις τιμές των ιδιωτικών μελών δεδομένων. Δημιουργήστε ένα αντικείμενο της κλάσης Α με ακέραιες τιμές και ένα αντικείμενο με πραγματικές τιμές.

    * [template2.cpp](./template2.cpp)

* Εξαιρέσεις

    Γράψτε πρόγραμμα που να δέχεται 2 πραγματικές τιμές και να υπολογίζει το πηλίκο τους. Χειριστείτε την περίπτωση που ο παρονομαστής είναι μηδέν με εξαίρεση, εμφανίζοντας κατάλληλο μήνυμα.

* Λάμδα συναρτήσεις

    Κατασκευάστε μια λάμδα συνάρτηση που να δέχεται 2 ακέραιες τιμές και να επιστρέφει το άθροισμα όλων των τιμών ανάμεσα στις δύο αυτές τιμές, συμπεριλαμβανομένων και των ίδιων των ακραίων τιμών. Καλέστε τη συνάρτηση και εμφανίστε το αποτέλεσμα για 3 ζεύγη τιμών που θα ορίσετε.

    * [lambda1.cpp](./lambda1.cpp)

## STL

### Περιέκτες (containers)

* std::vector

    Εισάγετε σε ένα std::vector όλες τις άρτιες τιμές από το 0 μέχρι και το 100. Εμφανίστε με range based for το περιεχόμενο του διανύσματος σε μια γραμμή.

    * [vector1.cpp](./vector1.cpp)

* std::array

    Μεταφέρετε τα στοιχεία ενός πίνακα 10 θέσεων ακεραίων σε ένα std::array. Αλλάξτε τις τιμές κάθε θέσης του array έτσι ώστε να συσσωρεύουν το άθροισμα από όλες τις προηγούμενες θέσεις. Εμφανίστε το περιεχόμενο του array.

    * [array1.cpp](./array1.cpp)

* std::list

    Για όλες τις ακέραιες τιμές από το 1 μέχρι και το 20 εισάγετε τις τιμές εναλλάξ την μια στην αρχή και την άλλη στο τέλος ενός std::list. Εμφανίστε τη λίστα.

    * [list1.cpp](./list1.cpp)

* std::set

    Εισάγετε 10 ακέραιες τιμές σε ένα std::set. Εμφανίστε ταξινομημένες τις τιμές. Πόσες τιμές εμφανίζονται;

    * [set1.cpp](./set1.cpp)

* std::unordered_set

    Εισάγετε 10 ακέραιες τιμές σε ένα std::unordered_set. Εμφανίστε ταξινομημένες τις τιμές. Πόσες τιμές εμφανίζονται;

    * [unordered_set1.cpp](./unordered_set1.cpp)

* std::map

    Χρησιμοποιώντας ένα std::map μετρήστε το πλήθος των ψηφίων που υπάρχουν σε όλους τους ακέραιους αριθμούς από το 1 μέχρι το 10000000. Εμφανίστε το πλήθος των παρατηρήσεων κάθε ψηφίου.

    * [map1.cpp](./map1.cpp)

* std::unordered_map

    Χρησιμοποιώντας ένα std::unordered_map μετρήστε το πλήθος των ψηφίων που υπάρχουν σε όλους τους ακέραιους αριθμούς από το 1 μέχρι το 10000000. Εμφανίστε το πλήθος των παρατηρήσεων κάθε ψηφίου. Γιατί η τρέχουσα λύση εκτελείται ταχύτερα σε σχέση με τη λύση του προηγούμενου ερωτήματος;

    * [unordered_map1.cpp](./unordered_map1.cpp)

### Επαναλήπτες (iterators)

* random iterator

    Εισάγετε σε ένα std::vector ακεραίων 10 τιμές. Διανύστε με random iterator το διάνυσμα αυξάνοντας την τιμή κάθε στοιχείου του κατά 1. Εμφανίστε το διάνυσμα.
  
* forward iterator

    Εισάγετε σε ένα std::list ακεραίων 10 τιμές. Διανύστε τη λίστα με forward iterator διαγράφοντας όλες τις άρτιες τιμές. Εμφανίστε τη λίστα.

### Αλγόριθμοι (algorithms)

* std::sort

    Εισάγετε 10 ακέραιες τιμές σε ένα std::vector. Εμφανίστε το άθροισμα των 5 μικρότερων.

* std::find

    Εισάγετε 10 ακέραιες τιμές σε ένα std::vector. Εξετάστε αν ο μέσος όρος των τιμών υπάρχει στο std::vector.

* std::copy

    Εισάγετε 10 ακέραιες τιμές σε ένα std::vector. Αντιγράψτε τις 5 πρώτες τιμές σε ένα άλλο std::vector.
    
* std::count_if

    Εισάγετε 10 ακέραιες τιμές σε ένα std::vector. Μετρήστε τις άρτιες τιμές.

* std::accumulate

    Εισάγετε 10 ακέραιες τιμές σε ένα std::vector. Υπολογίστε το άθροισμα και το γινόμενο των στοιχείων χωρίς να γράψετε εντολή επανάληψης.

### Βοηθήματα (utilities)

* ζεύγη (std::pair)

    Χρησιμοποιώντας std::pair για την αναπαράσταση ενός ζεύγους ακεραίων τιμών εισάγεται 5 ζεύγη τιμών σε ένα std::vector, ταξινομήστε τα στοιχεία του με βάση το άθροισμα των στοιχείων κάθε ζεύγους και εμφανίστε τα ζεύγη. 
  
* πλειάδες (std::tuple)

    Χρησιμοποιώντας std::tuple για την αναπαράσταση μιας τριάδας ακεραίων τιμών εισάγεται 5 τριάδες τιμών σε ένα std::vector, ταξινομήστε τα στοιχεία του με βάση το άθροισμα των στοιχείων κάθε τριάδας και εμφανίστε τις τριάδες. 


## OO Design (UML - Διαγράμματα κλάσεων)

* Διάγραμμα κλάσης 

### IS-A (κληρονομικότητα)

* Γενίκευση (inheritance)

### HAS-A (συσχέτιση, composition=σύνθεση ή aggregation=συνάθροιση)

* Συσχετίσεις μιας κατεύθυνσης (one way associations)

* Συνάθροιση (aggregation)

* Σύνθεση (composition)
