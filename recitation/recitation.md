# Προετοιμασία για τις εξετάσεις στο μάθημα «Αντικειμενοστραφής Προγραμματισμός» με τη C++

Θα πρέπει να είστε σε θέση να:
* κατανοείτε τη χρήση των δεικτών
* κάνετε δέσμευση και αποδέσμευση μνήμης
* κατανοείτε τον ορισμό και την χρήση πινάκων
* γράφετε συναρτήσεις
* κατανοείτε τη διαφορά ανάμεσα στην κλήση με τιμή και στην κλήση με αναφορά
* κατανοείτε τη χρήση των αναφορών
* γράφετε κλάσεις και να δημιουργείτε αντικείμενα των κλάσεων
* ορίζετε κατασκευαστές και καταστροφείς
* κατανοείτε τη χρήση του const
* ορίζετε υπερφορτωμένους τελεστές
* χρησιμοποιείτε την κληρονομικότητα
* κατανοείτε την έννοια των αφηρημένων κλάσεων
* ορίζετε πολυμορφικές ιεραρχίες
* προγραμματίζετε με πρότυπα (template programming)
* χρησιμοποιείτε λάμδα συναρτήσεις
* χρησιμοποιείτε STL περιέκτες
* χρησιμοποιείτε STL επαναλήπτες
* χρησιμοποιείτε STL αλγορίθμους
* διαβάζετε απλά διαγράμματα κλάσεων UML και να τα μετατρέπετε σε C++ κώδικα
* κατανοείτε βασικές διαφορές της C++ από την Java

## Γνώσεις από τη C 

* Δείκτες (dereference=αποαναφορά, διευθύνσεις)

    Τι θα εμφανίσει ο ακόλουθος κώδικας κατά την εκτέλεσή του;

    ```
    int a, b, c;
    int *x = &a, *y = &b;

    *x = 42;
    *y = 52;
    a++;
    b -= 2;
    *x += a;
    y = &c;
    *y = *x + b;

    cout << a << endl;
    cout << b << endl;
    cout << c << endl;
    cout << *x << endl;
    cout << *y << endl;
    cout << (x == &a) << endl;
    cout << (x == &b) << endl;
    cout << (x == &c) << endl;
    ```

    *   [pointers1.cpp](./pointers1.cpp)

* Κλήση με τιμή και κλήση με αναφορά με χρήση δεικτών

    Γράψτε μια συνάρτηση με όνομα circle που να δέχεται μια παράμετρο που να αντιστοιχεί στην ακτίνα ενός κύκλου και να επιστρέφει το εμβαδόν του κύκλου και την περίμετρο του κύκλου.

    * [call_by_reference1.cpp](./call_by_reference1.cpp)

* Δέσμευση, αποδέσμευση μνήμης (malloc, free)

    Γράψτε πρόγραμμα που να δεσμεύει θέσεις μνήμης για μια ακέραια, μια πραγματική (double) και μια τιμή χαρακτήρα, να αναθέτει μια τιμή σε κάθε δεσμευμένη θέση μνήμης και να απελευθερώνει τη μνήμη

    * [dynamic_memory1.cpp](./dynamic_memory1.cpp)

* Στατικοί, δυναμικοί πίνακες

    Γράψτε πρόγραμμα που να δημιουργεί έναν πίνακα 5 θέσεων με τις τιμές {2,7,1,3,6}. Να δέχεται από τον χρήστη μια ακέραια τιμή x και να αντιγράφει τον πίνακα x φορές σε έναν δυναμικό πίνακα τον οποίο στην συνέχεια να εμφανίζει στην οθόνη. Να αποδεσμεύει τον πίνακα πριν τον τερματισμό του προγράμματος

    * [static_dynamic_arrays1.cpp](./static_dynamic_arrays1.cpp)

* Δισδιάστατοι πίνακες

    Γράψτε πρόγραμμα που να δημιουργεί έναν πίνακα 5x5 που σε κάθε στοιχείο του να έχει ως τιμή το άθροισμα των δεικτών του στοιχείου (π.χ. στο στοιχείο a[2][3] να έχει την τιμή 2+3=5). Εμφανίστε τον πίνακα.

    * [two_dimensional_array1.cpp](./two_dimensional_array1.cpp)

* enums

    Δημιουργήστε ένα enumeration με τιμές ΟΝ και ΟΝ. Γράψτε ένα πρόγραμμα που να ορίζει έναν πίνακα με 5 τιμές ΟΝ ή OFF. Μετρήστε πόσα είναι τα ON και εμφανίστε το αποτέλεσμα.

    * [enum1.cpp](./enum1.cpp)

* Casting

    Τι θα εμφανίσει ο ακόλουθος κώδικας;

    ```
    int a=10,b=3;
    double c;

    c= a/b;
    cout << c << endl;
    c=(double)a/b;
    cout << c << endl;
    c=(double)a/(double)b;
    a = c;
    cout << a << endl;
    ```

    * [casting1.cpp](./casting1.cpp)

* inline συναρτήσεις

    Γράψτε ένα πρόγραμμα που να δημιουργεί ένα σύνολο από 10 σημεία στο καρτεσιανό επίπεδο. Γράψτε μια συνάρτηση distance που να επιστρέφει την απόσταση δύο σημείων. Ορίστε τη συνάρτηση ως inline και εντοπίστε τα σημεία που απέχουν τη μικρότερη απόσταση.

    * [inline1.cpp](./inline1.cpp)

* Χωριστή μεταγλώττιση

    Για τη δευτεροβάθμια εξίσωση: ax^2+bx+c=0
    Γράψτε μια συνάρτηση που να υπολογίζει τη διακρίνουσα. Γράψτε μια συνάρτηση που να επιστρέφει τις ρίζες της δευτεροβάθμιας εξίσωσης καθώς και μια τιμή (1 ή 0) που να υποδηλώνει το εάν υπάρχουν πραγματικές ρίζες ή όχι.

    * [quadratic_single_file.cpp](./quadratic_single_file.cpp)

    Γράψτε  ξεχωριστά header και source αρχεία (quadratic.hpp, quadratic.cpp) καθώς και ένα πρόγραμμα οδήγησης (main.cpp). Δώστε τις εντολές μεταγλώττισης και εκτέλεσης του προγράμματος.

    * [quadratic.hpp](./quadratic.hpp)
    * [quadratic.cpp](./quadratic.cpp)
    * [quadratic_main.cpp](./quadratic_main.cpp)

    Μεταγλώττιση:

    $ g++ quadratic.cpp quadratic_main.cpp -o quadratic

## C++

* Δέσμευση, αποδέσμευση μνήμης (new, delete)

    Γράψτε πρόγραμμα που να δεσμεύει θέσεις μνήμης για μια ακέραια, μια πραγματική (double) και μια τιμή χαρακτήρα, να αναθέτει μια τιμή σε κάθε δεσμευμένη θέση μνήμης και να απελευθερώνει τη μνήμη

    * [dynamic_memory2.cpp](./dynamic_memory2.cpp)

* Χώροι ονομάτων (namespaces)

    Ορίστε ένα namespace uoi και μέσα σε αυτό ένα άλλο namespace dit. Ορίστε 3 συναρτήσεις με όνομα fun στο global, στο uoi και στο dit namespace. Στη main καλέστε και τις 3 συναρτήσεις fun.

    * [namespace1.cpp](./namespace1.cpp)

* enum classes

    Δημιουργήστε ένα enumeration class με τιμές ΟΝ και ΟΝ. Γράψτε ένα πρόγραμμα που να ορίζει έναν πίνακα με 5 τιμές ΟΝ ή OFF. Μετρήστε πόσα είναι τα ON και εμφανίστε το αποτέλεσμα.

    * [enum2.cpp](./enum2.cpp)

* Αναφορές (references)

    Τι θα εμφανίσει ο ακόλουθος κώδικας;

    ```
    int a = 2;
    int &r = a;
    a += 2;
    r *= 2;
    cout << a << endl;
    cout << r << endl;
    ```

    * [reference1.cpp](./reference1.cpp)

* Πέρασμα με τιμή, πέρασμα με αναφορά με χρήση αναφορών

    Γράψτε μια συνάρτηση με όνομα circle που να δέχεται μια παράμετρο που να αντιστοιχεί στην ακτίνα ενός κύκλου και να επιστρέφει το εμβαδόν του κύκλου και την περίμετρο του κύκλου.

    * [call_by_reference2.cpp](./call_by_reference2.cpp)

* Χρήση του const

* Ορισμός κλάσεων (private/public members)

* Κατασκευαστές (προκαθορισμένος, υπερφόρτωση, default παράμετροι)

* Κατασκευαστής αντιγραφής (shallow copy/deep copy)

* Τελεστής ανάθεσης (assignment operator)

* Καταστροφείς

* Στατικά μέλη κλάσεων

* Φίλες συναρτήσεις

* Φίλες κλάσεις

* Υπερφόρτωση τελεστών (+, <, ==, « , »)

* Εμφωλιασμοί κλάσεων (nested classes)

* Μετατροπή αντικειμένου σε λεκτικό

* Κληρονομικότητα (βασικές κλάσεις, παραγόμενες κλάσεις, το keyword protected)

* Κληρονομικότητα (overload, override)

* Κληρονομικότητα (τα keywords final, override)

* upcasting, downcasting

* Πολυμορφικές ιεραρχίες (virtual συναρτήσεις)

* virtual destructors

* αφηρημένες κλάσεις (pure virtual functions)

* πολλαπλή κληρονομικότητα (διαχείριση συγκρούσεων)

* virtual πολλαπλή κληρονομικότητα

* templates (εφαρμογή σε συναρτήσεις, εφαρμογή σε δομές/κλάσεις)

* Εξαιρέσεις

* Λάμδα συναρτήσεις

* Δημιουργία τυχαίων τιμών

* Χρονομέτρηση εκτέλεσης κώδικα

* Χειρισμός αρχείων κειμένου και δυαδικών αρχείων

## STL

### Περιέκτες (containers)

* std::vector

* std::array

* std::list

* std::set

* std::unordered_set

* std::map

* std::unordered_map

### Επαναλήπτες (iterators)

* random iterator
  
* forward iterator

### Αλγόριθμοι (algorithms)

* std::sort

* std::find

* std::copy

* std::count_if

* std::accumulate

* std::lower_bound

### Βοηθήματα (utilities)

* ζεύγη (std::pair)
  
* πλειάδες (std::tuple)

## OO Design

* IS-A (κληρονομικότητα)

### HAS-A (composition=σύνθεση ή aggregation=συνάθροιση)

UML - Διαγράμματα κλάσεων

* Διάγραμμα κλάσης μεμονωμένης κλάσης

* Συσχετίσεις μιας κατεύθυνσης (one way associations)

* Συσχετίσεις δύο κατευθύνσεων (two way associations)

* Εξάρτηση (dependency)

* Συνάθροιση (aggregation)

* Σύνθεση (composition)

* Γενίκευση (inheritance)

* Υλοποίηση (realization)
