# Ασκήσεις εργαστηρίων

## Άσκηση 1

* Κατασκευάστε μια κλάση με όνομα cargo (φορτίο) με μέλη δεδομένων τα ακόλουθα: 
  * id (αναγνωριστικός αριθμός φορτίου) τύπου int.
  * destination (προορισμός) τύπου string.
  * weight (βάρος) τύπου double.
  * fragile (εύθραυστο) τύπου bool.
* Δημιουργήστε προκαθορισμένο κατασκευαστή που να δίνει τις εξής τιμές: 0, "Undefined", 0, false.
* Δημιουργήστε έναν κατασκευαστή που να θέτει όλα τα μέλη δεδομένων σε τιμές που θα δέχεται ως παραμέτρους.
* Δημιουργήστε getters και setters μόνο το πεδίο weight.
* Δημιουργήστε μια συνάρτηση show() που να εμφανίζει τις τιμές όλων των πεδίων του αντικειμένου.
* Δημιουργήστε μια συνάρτηση μέλος make_safe() που εφόσον ένα φορτίο δεν είναι fragile να το κάνει και να αυξάνει το βάρος του κατά 5 κιλά (για υλικά συσκευασίας).
* Στη main:
  * Εισάγετε σε έναν πίνακα 5 θέσεων αντικείμενα cargo ως εξής:
    * 1, Patras, 1000, false
    * 2, Athens, 200, true
    * 3, Kalamata, 2000, false
    * 4, Patras, 1500, true
    * 5, Athens, 1100, false
  * Με μια επανάληψη πραγματοποιήστε κλήση της make_safe για όλα τα αντικείμενα.
  * Εμφανίστε όλα τα αντικείμενα.

### Λύση άσκησης 1

* [cargo_example.cpp](./lab_ex1/cargo_example.cpp)

---

Επιπλέον ερωτήματα:

* Υπερφορτώστε τον τελεστή << έτσι ώστε να μπορεί να χρησιμοποιηθεί με το cout και να εμφανίζει τις τιμές όλων των πεδίων του αντικειμένου.
* Υπερφορτώστε τον τελεστή == έτσι ώστε να επιστρέφει true αν όλα τα πεδία δεδομένων των αντικειμένων είναι ίδια.
* Υπερφορτώστε τον τελεστή < έτσι ώστε να διατάσσει αντικείμενα cargo με βάση το βάρος τους (σε αύξουσα σειρά).
* Υπερφορτώστε και τους άλλους συγκριτικούς τελεστές.
* Ταξινομήστε τον πίνακα των αντικειμένων (χρησιμοποιήστε την STL συνάρτηση sort).
* Προσθέστε στατική μεταβλητή count που  να καταμετρά το πλήθος των αντικειμένων που δημιουργούνται. Εμφανίστε την τιμή της count στο τέλος της main.
* Διασπάστε τον κώδικα στα αρχεία cargo.hpp, cargo.cpp, driver.cpp. Μεταγλωττίστε τον κώδικα και εκτελέστε τον.
* Προσθέστε unit tests με το catch2 έτσι ώστε να ελέγχεται η ορθή υλοποίηση της συνάρτησης make_safe(). Δημιουργήστε για το λόγο αυτό το αρχείο tests.cpp.
<!-- * Χρησιμοποιήστε τη βιβλιοθήκη fmt για εμφάνιση αποτελεσμάτων στην οθόνη. -->

### Λύση επιπλέον ερωτημάτων άσκησης 1

* [cargo.hpp](./lab_ex1_sol/cargo.hpp)
* [cargo.cpp](./lab_ex1_sol/cargo.cpp)
* [driver.cpp](./lab_ex1_sol/driver.cpp)
* [tests.cpp](./lab_ex1_sol/tests.cpp) (θα πρέπει να υπάρχει το catch.hpp στην κατάλληλη θέση ..)

## Άσκηση 2

Δημιουργήστε ένα πρόγραμμα που να υπολογίζει την ημερομηνία και την ημέρα της εβδομάδας για το ημερολογιακό έτος 2020. Για το σκοπό αυτό θα κατασκευαστεί η κλάση date2020.

* Συμπληρώστε την κλάση date2020 στα δύο αρχεία date2020.hpp και date2020.cpp. Η κλάση έχει δύο int ιδιωτικά μέλη δεδομένων d για την ημέρα και m  για τον μήνα. Αν η ημερομηνία δεν είναι έγκυρη ημερομηνία του 2020 τότε να θέτει m=-1 και d=-1. Υλοποίηστε την ακόλουθη διεπαφή για την κλάση  date2020:
  * date2020();
    * O προκαθορισμένος κατασκευαστής date2020() θα θέτει ως ημερομηνία 1 January 2020.
  * date2020(int d, int m);
    * Ο κατασκευαστής date2020(int d, int m) θα δέχεται ημέρα και μήνα και θα θέτει την ημερομηνία κατάλληλα.
  * void plus_days(int days);
    * Η συνάρτηση plus_days(int days) θα προσθέτει days ημέρες στην τρέχουσα ημερομηνία.
  * date2020(int d);
    * Ο κατασκευαστής date2020(int d) θα δέχεται τιμές από το 1 μέχρι και το 366 και θα θέτει την ημερομηνία ως την ημερομηνία d μέρες από την έναρξη του έτους 2020.
  * string get_day_name();
    * H συνάρτηση get_day_name() θα επιστρέφει το όνομα της ημέρας στο οποίο αντιστοιχεί η ημερομηνία.
  * void print(); (έχει ήδη υλοποιηθεί)
    * Η συνάρτηση print() θα εκτυπώνει την ημερομηνία όπως στο παράδειγμα που ακολουθεί: 15 March 2020 - (Sunday - 75).
  * int get_days_in_year(); (έχει ήδη υλοποιηθεί)
    * Η συνάρτηση get_days_in_year() θα επιστρέφει το πλήθος των ημερών από την αρχή τους έτους στο οποίο αντιστοιχεί η ημερομηνία.
* Εκτελέστε το πρόγραμμα οδηγό main.cpp και καταγράψτε την έξοδό του σε ένα αρχείο με όνομα main.out.
* Εκτελέστε τα unit tests που περιέχονται στο tests.cpp.

### Αρχεία άσκησης

* [date2020.hpp](./lab_ex2/date2020.hpp)
* [date2020.cpp](./lab_ex2/date2020.cpp)
* [main.cpp](./lab_ex2/main.cpp)
* [tests.cpp](./lab_ex2/tests.cpp) (θα πρέπει να υπάρχει το catch.hpp στην κατάλληλη θέση ..)

Η μεταγλώττιση και η εκτέλεση του προγράμματος γίνεται ως εξής:

```bash
$ g++ date2020.cpp main.cpp -o main -std=c++11
./main

$ g++ date2020.cpp tests.cpp -o tests -std=c++11
./tests
```

### Λύση άσκησης 2

* [date2020.hpp](./lab_ex2_sol/date2020.hpp)
* [date2020.cpp](./lab_ex2_sol/date2020.cpp)
* [main.cpp](./lab_ex2_sol/main.cpp)
* [tests.cpp](./lab_ex2_sol/tests.cpp) (θα πρέπει να υπάρχει το catch.hpp στην κατάλληλη θέση ..)

## Άσκηση 3

* Θέμα 2 από τα [θέματα προετοιμασίας](https://chgogos.github.io/oop/preparation/proodos.pdf) (κληρονομικότητα)

### Λύση άσκησης 3

* <https://chgogos.github.io/oop/preparation/prepare02.cpp>

## Άσκηση 4

* Δημιουργήστε δύο κλάσεις οrder (παραγγελία) και line_item (αντικείμενο παραγγελίας).
* Η κλάση order να έχει ως πεδία μέλη: number (αριθμό παραγγελίας), ordered (ημερομηνία παραγγελίας), shipped (ημερομηνία παράδοσης) και ship_to (τοποθεσία παράδοσης).
* Η κλάση line_item να έχει ως πεδία μέλη: product (ονομασία προϊόντος), quantity (ποσότητα) και price (τιμή).
* Η κλάση order να διατηρεί ένα std::vector με τα line_items που αντιστοιχούν σε κάθε παραγγελία.
* Υπερφορτώστε τον operator<< τόσο για τα αντικείμενα order όσο και για τα αντικείμενα line_item.
* Γράψτε πρόγραμμα οδηγό (main1.cpp) που να δημιουργεί μια παραγγελία με 3 συσχετιζόμενα αντικείμενα παραγγελίας και μια ακόμη παραγγελία με 1 συσχετιζόμενο αντικείμενο παραγγελίας. Προσθέστε τις παραγγελίες σε ένα std::vector. Διανύστε το vector και εμφανίστε τα αποτελέσματα στην οθόνη.

---

### Επιπλέον ερωτήματα

* Γράψτε νέο πρόγραμμα οδηγό (main2.cpp) που να δημιουργεί μια Βάση Δεδομένων στην SQLite3 η οποία να μπορεί να δεχθεί δεδομένα αντικειμένων των παραπάνω κλάσεων. Για το σκοπό αυτό δημιουργήστε τους πίνακες ORDERS και LINE_ITEMS. Εισάγετε δεδομένα στους πίνακες έτσι ώστε να υπάρχουν 3 παραγγελίες με κάποια αντικείμενα παραγγελίας για κάθε παραγγελία.
* Συμπληρώστε κώδικα στο πρόγραμμα οδηγό έτσι ώστε να ανακαλεί τα δεδομένα από τη Βάση Δεδομένων, να τα εισάγει σε αντικείμενα και να τα εμφανίζει.

* [Λύση άσκησης 4](./lab_ex4_sol)

### Άσκηση 5

* Επίλυση των ερωτημάτων της [εργασίας 2](./exercise2/20200310_assignment2.pdf). Χρησιμοποιήστε ως αρχικό κώδικα τον κώδικα που θα βρείτε στο <https://github.com/chgogos/oop/tree/master/lab2020/exercise2>. Ειδικότερα υλοποίηστε τις ακόλουθες συναρτήσεις.
  * συνάρτηση int linked_list::length();
  * συνάρτηση int linked_list::sum();
  * συνάρτηση void linked_list::erase_front();
  * συνάρτηση void linked_list::push_back(int d);
  * συνάρτηση void linked_list::bubble_sort();
  * copy constructor, linked_list(const linked_list &ll);
* Επιπλέον, επίλυση των ακόλουθων ερωτημάτων (μαζί με unit tests):
  * Διαγραφή στοιχείου από συγκεκριμένη θέση (π.χ. διαγραφή του στοιχείου στη θέση 2 για τη συνδεδεμένη λίστα 10->20->12->7 θα πρέπει να δίνει τη συνδεδεμένη λίστα 10->20->7).
  * Εισαγωγή στοιχείου σε συγκεκριμένη θέση (π.χ. εισαγωγή του στοιχείου 42 στη θέση 2 για τη συνδεδεμένη λίστα 10->20->12->7 θα πρέπει να δίνει τη συνδεδεμένη λίστα 10->20->42->12->7).
  * Αντιστροφή της συνδεδεμένης λίστας (π.χ. η συνδεδεμένη λίστα 10->20->12->7 θα πρέπει να γίνεται 7->12->20->10).