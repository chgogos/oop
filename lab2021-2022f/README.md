# ΕΡΓΑΣΤΗΡΙΟ ΧΕΙΜΕΡΙΝΟΥ ΕΞΑΜΗΝΟΥ 2021-2022

Η διδασκαλία των εργαστηρίων γίνεται δια ζώσης. Η διάρκεια κάθε εργαστηρίου είναι 2 ώρες και κάθε ΟΜΑΔΑ προσέρχεται ανά δύο εβδομάδες στο εργαστήριο. 

**Ομάδες εργαστηρίων**

* Δευτέρα 3-5 (ΟΜΑΔΑ 1 - εργαστήριο Ε4) 11/10/2021, 25/10/2021, ...
* Δευτέρα 3-5 (ΟΜΑΔΑ 2 - εργαστήριο Ε4) 18/10/2021, 01/11/2021, ...
* Δευτέρα 5-7 (ΟΜΑΔΑ 3 - εργαστήριο Ε4) 11/10/2021, 25/10/2021, ...
* Δευτέρα 5-7 (ΟΜΑΔΑ 4 - εργαστήριο Ε4) 18/10/2021, 01/11/2021, ...
* Πέμπτη 2-4 (ΟΜΑΔΑ 5 - εργαστήριο Ε5)  14/10/2021, ~~28/10/2021~~, ...
* Πέμπτη 2-4 (ΟΜΑΔΑ 6 - εργαστήριο Ε5) 21/10/2021, 04/11/2021, ...
* Παρασκευή 4-6 (ΟΜΑΔΑ 7 - εργαστήριο Ε5) 15/10/2021, 29/10/2021, ...
* Παρασκευή 4-6 (ΟΜΑΔΑ 8 - εργαστήριο Ε5) 22/10/2021, 05/11/2021, ...

## Εργαστήριο 1 (11/10/2021 - 22/10/2021)

* Εγκατάσταση και ρύθμιση περιβάλλοντος ανάπτυξης εφαρμογών σε C++
  * GCC compiler για Windows [TDM-GCC](https://jmeubank.github.io/tdm-gcc/)
  * Επεξεργαστής κειμένου [Visual Studio Code](https://code.visualstudio.com/) (VS Code)
  * Extensions για το VS Code για C++
    * [ms-vscode.cpptools](https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools)
    * [formulahendry.code-runner](https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner)
* Συγγραφή προγραμμάτων σε C++, μεταγλώττιση και εκτέλεση από το VS Code
  * [hello1.cpp](./../cpp_playground/ex001/hello1.cpp)
  * [hello2.cpp](./../cpp_playground/ex001/hello2.cpp)
  * [hello3.cpp](./../cpp_playground/ex001/hello3.cpp)
* Μεταγλώττιση και εκτέλεση προγραμμάτων από τη γραμμή εντολών
  * τα switches -c, -o, -g, -O2, -Wall, -Werror, -std (c++98, c++03, c++11, c++14, c++17, c++20, ...)
    * [source.cpp](./lab01/source.cpp) για παραδείγματα μεταγλώττισης με -c, -o, -g, -O2
    * [warning_examples.cpp](./lab01/warning_examples.cpp) για παραδείγματα μεταγλώττισης με -Wall, -Werror
    * [std_examples.cpp](./lab01/std_examples.cpp) για παραδείγματα μεταγλώττισης με -std=c++98, -std=c++11
* Αποσφαλμάτωση κώδικα (debugging)
  * Χρήση του Run & Debug του VS Code (βηματική εκτέλεση, breakpoints, watches ...)
  * [Παραδείγματα debugging](../various/DEBUG_EXAMPLES/README.md)
* Διαχωρισμός header / source αρχείων
  * [numbers.hpp](./../cpp_playground/ex110/numbers.hpp)
  * [numbers.cpp](./../cpp_playground/ex110/numbers.cpp)
  * [main.cpp](./../cpp_playground/ex110/main.cpp)
  * Μεταγλώττιση και εκτέλεση
    ```
    > g++ numbers.cpp main.cpp -o main
    > main.exe
    GCD of 30 and 12 is 6
    LCM of 30 and 12 is 60
    ```
* Συναρτήσεις, πέρασμα με τιμή, πέρασμα με αναφορά
  * [calls.cpp](./../cpp_playground/ex001/calls.cpp)
  * Παράδειγμα: Γράψτε μια συνάρτηση που να δέχεται τις πλευρές ενός ορθογωνίου παραλληλογράμμου και να επιστρέφει την περίμετρο και το εμβαδόν του μέσω των παραμέτρων της. Καλέστε τη συνάρτηση από το κύριο πρόγραμμα.
    * [call_by_ref_example.cpp](./lab01/call_by_ref_example.cpp)
* Ο ρόλος των στατικών μεταβλητών σε συναρτήσεις
  * [static1.c](./../cpp_playground/ex013/static1.c)
  * [static2.cpp](./../cpp_playground/ex013/static2.cpp)
* Η βιβλιοθήκη Catch2 για συγγραφή ελέγχων
  * [Παραδείγματα](../catch2_examples/README.md) 

## Εργαστήριο 2 (25/10/2021 - 5/11/2021)

* Δομές (structs) - εγγραφές
  * Παράδειγμα: Ζητείται η δημιουργία μιας δομής circle με τα πεδία center_x, center_y για τις συντεταγμένες του κέντρου του κύκλου και το πεδίο radius για την ακτίνα του κύκλου. Προσθέστε συναρτήσεις για τον υπολογισμό του εμβαδού και της περιμέτρου ενός κύκλου. Προσθέστε μια συνάρτηση που να ελέγχει αν ένα σημείο βρίσκεται εντός ή εκτός ενός κύκλου. Συμπληρώστε στη main κώδικα που να δημιουργεί εγγραφές και να καλεί τις ανωτέρω συναρτήσεις.
    * [struct_circle_example.cpp](./lab02/struct_circle_example.cpp)
* Κλάσεις - αντικείμενα
  * Παράδειγμα: Ζητείται η δημιουργία μιας κλάσης circle με ιδιωτικά μέλη δεδομένων center_x, center_y για τις συντεταγμένες του κέντρου του κύκλου και το ιδιωτικό μέλος δεδομένων radius για την ακτίνα του κύκλου. Συμπληρώστε 2 constructors και τον destructor έτσι ώστε να εμφανίζονται μηνύματα όταν δημιουργείται και όταν καταστρέφεται ένα αντικείμενο.Προσθέστε συναρτήσεις μέλη για τον υπολογισμό του εμβαδού και της περιμέτρου του κύκλου. Προσθέστε μια συνάρτηση μέλος που να ελέγχει αν ένα σημείο βρίσκεται εντός ή εκτός του κύκλου. Συμπληρώστε στη main κώδικα που να δημιουργεί αντικείμενα και να καλεί τις ανωτέρω συναρτήσεις.
    * [class_circle_example.cpp](./lab02/class_circle_example.cpp)
* Δημόσια, ιδιωτική πρόσβαση (ενθυλάκωση) 
  * Παράδειγμα: Γράψτε ένα πρόγραμμα που να ορίζει μια κλάση Α με ένα ακέραιο ιδιωτικό μέλος δεδομένων x και ένα ακέραιο δημόσιο μέλος δεδομένων y. Συμπληρώστε τον απαιτούμενο κώδικα sto [protection_levels_example.cpp](./lab02/protection_levels_example.cpp) έτσι ώστε για ένα αντικείμενο που δημιουργείται στη main να εμφανίζεται τόσο η τιμή του x όσο και η τιμή του y.
    * [protection_levels_example_sol.cpp](./lab02/protection_levels_example_sol.cpp)
* Κατασκευαστές 
  * Παράδειγμα: Γράψτε ένα πρόγραμμα που να ορίζει μια κλάση Α με δύο ακέραια ιδιωτικά μέλη δεδομένων x και y. Ορίστε 2 διαφορετικούς κατασκευαστές κάνοντας χρήση και προκαθορισμένης τιμής για την παράμετρο ενός κατασκευαστή. Στη main δημιουργείστε 1 αντικείμενο με τον προκαθορισμένο κατασκευαστή και 1 πίνακα 5 αντικειμένων με το δεύτερο κατασκευαστή.
    * [constructors_example.cpp](./lab02/constructors_example.cpp) 
* Καταστροφείς 
  * Παράδειγμα: Ορίστε τον καταστροφέα μιας κλάσης έτσι ώστε να εμφανίζει τη θέση μνήμης του αντικειμένου και το μέγεθος του αντικειμένου που καταστρέφεται. Στη main προκαλέστε διαδοχικά για 10 φορές σε μια for την κλήση του καταστροφέα.
    * [destructor_example.cpp](./lab02/destructor_example.cpp)
* Συναρτήσεις μέλη 
  * Παράδειγμα: Έστω μια κλάση Α που περιέχει μια ιδιωτική συνάρτηση fun που δέχεται μια ακέραια παράμετρο την οποία και εμφανίζει [member_functions_example.cpp](./lab02/member_functions_example.cpp). Προσθέστε τον κατάλληλο κώδικα έτσι ώστε στη main να εμφανίζεται το αποτέλεσμα της κλήσης της συνάρτησης fun.
    * [member_functions_example_sol.cpp](./lab02/member_functions_example_sol.cpp)
* Φίλες συναρτήσεις 
  * Παράδειγμα: Δημιουργήστε μια κλάση Α με ένα ακέραιο ιδιωτικό μέλος x. Συμπληρώστε μια φίλη συνάρτηση fun που να εκτυπώνει την τιμή του x για ένα αντικείμενο της κλάσης Α.
    * [friend_function_example.cpp](./lab02/friend_function_example.cpp)
* Η βιβλιοθήκη [fmt](https://fmt.dev/latest/index.html) για εύκολη εμφάνιση αποτελεσμάτων. 
  * [fmt_example1.cpp](./lab02/fmt_example1.cpp)
  * [fmt_example2.cpp](./lab02/fmt_example2.cpp)
  * [Χρήση](https://fmt.dev/latest/usage.html) δημιουργία φακέλου fmt στον φάκελο που βρίσκεται το fmt_example1.cpp, αντιγραφή των core.h, format-inl.h, format.h από το zip του fmt στον φάκελο fmt, αντιγραφή του format.cc από το zip του fmt στον ίδιο φάκελο με το fmt_example1.cpp
  * [Επιπλέον οδηγίες από το h/cpp hacking C++](https://hackingcpp.com/cpp/libs/fmt.html)

Μεταγλώττιση και εκτέλεση του fmt_example1.cpp

```cmd
$ g++ fmt_example1.cpp format.cc -ο fmt_example1 -std=c++11
$ fmt_example1.exe
The answer is 42.
Elapsed time: 1.23 seconds
Don't panic!
Elapsed time: 1.23 seconds
```

## Εργαστήριο 3 (8/11/2021 - 19/11/2021)

* Υπερφόρτωση (overload) συναρτήσεων. 
  * Παράδειγμα: Γράψτε κώδικα που να πραγματοποιεί υπερφόρτωση σε μια συνάρτηση με όνομα fun έτσι ώστε να υπάρχουν 3 εκδόσεις της, μια που να δέχεται 1 int παράμετρο, μια που να δέχεται 1 double παράμετρο και μια που να δέχεται 1 int και 1 double πράμετρο. Κάθε συνάρτηση, απλά να εμφανίζει τις τιμές των παραμέτρων της. Καλέστε και τις 3 συναρτήσεις από το κύριο πρόγραμμα. Επαναλάβατε το παράδειγμα ορίζοντας τις ανωτέρω συναρτήσεις ως συναρτήσεις μέλη μιας κλάσης A.
  * [function_overload.cpp](./lab03/function_overload.cpp)
  * [member_function_overload.cpp](./lab03/member_function_overload.cpp)
* Υπερφόρτωση τελεστών 
  * Παράδειγμα 1: Δημιουργήστε μια κλάση Α με 3 ακέραια ιδιωτικά μέλη δεδομένων. Υπερφορτώστε τον τελεστή < έτσι ώστε η σύγκριση αντικειμένων να γίνεται με βάση το άθροισμα των 3 ιδιωτικών μελών. Επιπλέον, υπερφορτώστε τον τελεστή << έτσι ώστε να εμφανίζονται τα 3 ιδιωτικά μέλη και το άθροισμά τους.
    * [overload1.cpp](./../recitation/overload1.cpp)
  * Παράδειγμα 2: Δημιουργήστε μια κλάση customer με 2 ιδιωτικά μέλη δεδομένων name και balance (υπόλοιπο λογαριασμού). Υπερφορτώστε τους τελεστές < και == για τα αντικείμενα customer έτσι ώστε η σύγκριση μεταξύ τους να γίνεται με βάση το υπόλοιπο του λογαριασμού. Στο κύριο πρόγραμμα δημιουργήστε αντικείμενα customer και χρησιμοποιήστε τους τελεστές < και ==.
    * [operator_overload4.cpp](./../cpp_playground/ex015/operator_overload4.cpp)
* Δείκτες, δέσμευση και αποδέσμευση μνήμης με new και delete
  * Παράδειγμα 1: Γράψτε μια συνάρτηση που να δέχεται 4 ακέραιες παραμέτρους. Κατά την κλήση της να επιστρέφει το άθροισμα και το γινόμενο των 2 πρώτων ορισμάτων στο τρίτο και στο τέταρτο όρισμα αντίστοιχα. Να χρησιμοποιηθούν δείκτες για την επιστροφή των τιμών. 
    * [pass_by_ref_using_pointers.cpp](./lab03/pass_by_ref_using_pointers.cpp)
  * Παράδειγμα 2: Γράψτε πρόγραμμα που να δεσμεύει θέσεις μνήμης για έναν int, έναν double και έναν char, να αναθέτει μια τιμή σε κάθε δεσμευμένη θέση μνήμης και στη συνέχεια να απελευθερώνει τη μνήμη.
    <!-- * [dynamic_memory1.cpp](./../recitation/dynamic_memory1.cpp) -->
    * [dynamic_memory2.cpp](./../recitation/dynamic_memory2.cpp)
  * Παράδειγμα 3: Το πρόβλημα των dangling pointers
    * [dangling_pointer.cpp](./../cpp_playground/ex001/dangling_pointer.cpp) 
* Πίνακες
  * Παράδειγμα: Γράψτε πρόγραμμα που να δημιουργεί έναν πίνακα 5 θέσεων με τις τιμές {2,7,1,3,6}. Να δέχεται από τον χρήστη μια ακέραια τιμή x και να αντιγράφει τον πίνακα x φορές σε έναν δυναμικό πίνακα τον οποίο στην συνέχεια να εμφανίζει στην οθόνη. Να αποδεσμεύει τον πίνακα πριν τον τερματισμό του προγράμματος
    <!-- * [static_dynamic_arrays1.cpp](./../recitation/static_dynamic_arrays1.cpp) -->
    * [static_dynamic_arrays2.cpp](./../recitation/static_dynamic_arrays2.cpp)
* Πολυδιάστατοι πίνακες
  * Παράδειγμα 1: Γράψτε πρόγραμμα που να δημιουργεί έναν πίνακα 5x5 που σε κάθε στοιχείο του να έχει ως τιμή το άθροισμα των δεικτών του στοιχείου (π.χ. στο στοιχείο a[2][3] να έχει την τιμή 2+3=5). Εμφανίστε τον πίνακα.
    * [two_dimensional_array1.cpp](./../recitation/two_dimensional_array1.cpp)
  * Παράδειγμα 2: Γράψτε συνάρτηση που να δέχεται ως παραμέτρους έναν δισδιάστατο πίνακα ακεραίων, τον αριθμό γραμμών και τον αριθμό στηλών του και να εμφανίζει τα περιεχόμενα του πίνακα. Καλέστε από το κύριο πρόγραμμα τη συνάρτηση για έναν δυναμικό πίνακα.
    * [matrix2b.cpp](./../cpp_playground/ex001/matrix2b.cpp)
* Κατασκευαστής αντιγραφής (copy constructor) που πραγματοποιεί αντιγραφή σε βάθος (deep copy)
  * Παράδειγμα: Γράψτε ένα πρόγραμμα που να ορίζει μια κλάση Α με ένα ιδιωτικό μέλος δεδομένων που να είναι δείκτης προς πίνακα ακεραίων. Συμπληρώστε έναν κατασκευαστή αντιγραφής που να πραγματοποιεί deep copy στα δεδομένα του πίνακα. Χρησιμοποιήστε τον κατασκευαστή αντιγραφής στη main.
    * [deep_copy1.cpp](./../recitation/deep_copy1.cpp)


## Εργαστήριο 4 (22/11/2021 - 3/12/2021)

* Κληρονομικότητα (inheritance), στατική πρόσδεση (static binding), δυναμική πρόσδεση (dynamic binding), παράκαμψη (override), προστατευμένα (protected) μέλη,  πολυμορφισμός, ιδεατές συναρτήσεις (virtual functions), καθαρές ιδεατές συναρτήσεις (pure virtual functions), αφηρημένες (abstract) κλάσεις
  * Παράδειγμα 1: Γράψτε πρόγραμμα που να ορίζει μια κλάση Person (άτομο) με ιδιωτικά μέλη δεδομένων name (όνομα) και age (ηλικία) τα οποία θα αρχικοποιούνται από κατάλληλο κατασκευαστή. Η κλάση Person να ορίζει μια ιδεατή συνάρτηση μέλος void say(string msg) που να εμφανίζει το μήνυμα "The person says: " ακολουθούμενο από το λεκτικό msg. Ορίστε την κλάση Student (σπουδαστής) που να κληρονομεί από την Person και να ορίζει το ιδιωτικό πεδίο semester (εξάμηνο). Συμπληρώστε έναν κατασκευαστή που να θέτει όλα τα μέλη δεδομένων της Student. Υπερφορτώστε τη συνάρτηση say έτσι ώστε το μήνυμα που εμφανίζει να είναι "The student says: " ακολουθούμενο από το λεκτικό msg. Δημιουργήστε αντικείμενα Person και Student. Πειραματιστείτε με την ανάθεση αντικειμένων Student σε δείκτες ή αναφορές σε Person.
    * [inheritance1.cpp](./lab04/inheritance1.cpp) 
  * Παράδειγμα 2: Γράψτε πρόγραμμα που να ορίζει μια κλάση date (ημερομηνία) με ιδιωτικά μέλη δεδομένων day (αριθμός ημέρας μήνα), month (αριθμός μήνα) και year (έτος). Συμπληρώστε 3 κατασκευαστές με κανένα, δύο και τρεις παραμέτρους αντίστοιχα. Ο κατασκευαστής χωρίς παραμέτρους να θέτει την ημερομηνία 1/1/2021. O κατασκευαστής με δύο παραμέτρους να τις χρησιμοποιεί για να θέσει αριθμό ημέρας και μήνα και να ορίζει ως έτος το 2021. Ο κατασκευαστής με τρεις παραμέτρους να να τις χρησιμοποιεί για να θέσει αριθμό ημέρας, αριθμό μήνα και έτος. Συμπληρώστε getters και για τα 3 πεδία. Συμπληρώστε μια ιδεατή συνάρτηση string desc() που να επιστρέφει την ημερομηνία με το συνηθισμένο τρόπο αναγραφής της (π.χ. 20/11/2021). Ορίστε μια κλάση holiday (αργία) που να κληρονομεί από την date και να ορίζει ένα επιπλέον ιδιωτικό πεδίο name (όνομα) που θα περιέχει το όνομα της αργίας. Παρακάμψτε τη συνάρτηση desc της date έτσι ώστε να εμφανίζει και το όνομα της αργίας. Πειραματιστείτε με τη χρήση αντικειμένων, αναφορών και δεικτών date ως παραμέτρων συναρτήσεων που καλούνται με αντικείμενα holiday. 
    * [inheritance2.cpp](./lab04/inheritance2.cpp)
  * Παράδειγμα 3: Γράψτε πρόγραμμα που να ορίζει τη βασική κλάση pet (κατοικίδιο) και τις παραγόμενες κλάσεις cat και dog. Η κλάση pet να είναι αφηρημένη, να ορίζει το προστατευμένο πεδίο _name, να ορίζει την καθαρή ιδεατή συνάρτηση string sound(), να ορίζει την ιδεατή συνάρτηση void make_sound() που θα εμφανίζει το όνομα του κατοικιδίου και ένα λεκτικό με τον χαρακτηριστικό του ήχο (π.χ. "woof", "miao"). Πειραματιστείτε με ανάθεση αντικειμένων cat και dog σε αναφορές και δείκτες σε pet.
    * [inheritance3.cpp](./lab04/inheritance3.cpp)
* Στατικά μέλη κλάσεων (μεταβλητές και συναρτήσεις)
  * Παράδειγμα: Καταμέτρηση πλήθους αντικειμένων με στατική μεταβλητή κλάσης.
    * [static_example1.cpp](./../cpp_playground/ex013/static_example1.cpp)

<!-- * Αποθήκευση δεδομένων σε αρχεία και ανάγνωση δεδομένων από αρχεία
  * Παράδειγμα: Γράψτε πρόγραμμα που να αποθηκεύει πληροφορίες φοιτητών (όνομα, βαθμό, εξάμηνο) σε ένα αρχείο κειμένου και στη συνέχεια να διαβάζει και να εμφανίζει τα περιεχόμενα του αρχείου.
    * [file2.cpp](./../cpp_playground/ex073/file2.cpp) -->
  

## Εργαστήριο 5 (6/12/2021 - 17/12/2021)

* Πρότυπα συναρτήσεων 
  * Παράδειγμα: Κατασκευάστε ένα πρότυπο συνάρτησης (template function) που να δέχεται ως παραμέτρους έναν πίνακα και το μέγεθος του και να επιστρέφει τη μεγαλύτερη τιμή του πίνακα. Ο τύπος των στοιχείων που θα περιέχει ο πίνακας θα ορίζεται κατά την κλήση της συνάρτησης. Πραγματοποιήστε κλήση της συνάρτησης για έναν πίνακα ακεραίων, για έναν πίνακα πραγματικών και για έναν πίνακα λεκτικών.
    * [template1.cpp](./../recitation/template1.cpp)
* Πρότυπα κλάσεων
  * Παράδειγμα: Κατασκευάστε ένα πρότυπο κλάσης με όνομα Stack που να χρησιμοποιείται για τη δημιουργία αντικειμένων στοίβας (λειτουργίες push, pop, top) με περιεχομένα τύπου που θα δηλώνει ο προγραμματιστής κατά τη δήλωση των αντικειμένων στοίβας. Χρησιμοποιήστε τη στοίβα α) για να πετύχετε την αντιστροφή ενός λεκτικού και β) για να εισάγετε 10 ακεραίους και εν συνεχεία να τους εμφανίσετε καθώς θα εξάγονται. 
    * [stack_example.cpp](./lab05/stack_example.cpp)
* Χειρισμός εξαιρέσεων
  * Παράδειγμα 1: Γράψτε συνάρτηση που να δέχεται 2 πραγματικές τιμές και να επιστρέφει το πηλίκο τους. Χειριστείτε την περίπτωση που ο παρονομαστής είναι μηδέν με εξαίρεση. Πραγματοποιήστε σύλληψη (catch) της εξαίρεσης στη main.
    * [exception1.cpp](./../recitation/exception1.cpp)
  * Παράδειγμα 2: Γράψτε πρόγραμμα που να αρχικοποιεί ένα std::vector με 5 τιμές. Στη συνέχεια πραγματοποιήστε πρόσβαση με κάποιο δείκτη εκτός των αποδεκτών ορίων δεικτών χρησιμοποιώντας τη συνάρτηση μέλος .at(int). Συλλάβετε την εξαίρεση std::out_of_range που θα γίνει throw και εμφανίστε κατάλληλο μήνυμα.
    * [stl_container_out_of_range.cpp](./../cpp_playground/ex046/stl_container_out_of_range.cpp)
* Λάμδα συναρτήσεις
  * Παράδειγμα 1: Κατασκευάστε μια λάμδα συνάρτηση που να δέχεται ως παραμέτρους 2 ακέραιες τιμές και να επιστρέφει το άθροισμα όλων των ακέραιων τιμών ανάμεσα στις δύο αυτές τιμές, συμπεριλαμβανομένων και των ίδιων των ακραίων τιμών. Καλέστε τη συνάρτηση και εμφανίστε το αποτέλεσμα για 3 ζεύγη τιμών που θα ορίσετε.
    * [lambda1.cpp](./../recitation/lambda1.cpp)
  * Παράδειγμα 2: Γράψτε πρόγραμμα που να αρχικοποιεί ένα διάνυσμα std::vector με ζεύγη ακέραιων τιμών, std::pair. Ταξινομήστε τα περιεχόμενα του διανύσματος σε φθίνουσα σειρά  αθροισμάτων που δημιουργούνται από τα στοιχεία του κάθε ζεύγους.
    * [sort_pair_sum.cpp](./lab05/sort_pair_sum.cpp)

<!-- * Δείκτες συνάρτησης -->

## Εργαστήριο 6 (20/12/2021 - 14/01/2022)

* Η βιβλιοθήκη STL (Standard Template Library)
* Containers (περιέκτες). Παραδείγματα με sequence containers (ακολουθιακούς περιέκτες) και με associative containers (συσχετιστικούς περιέκτες)
  * [std::vector](https://hackingcpp.com/cpp/std/vector.html). Διάνυσμα μεταβλητού μεγέθους (δυναμικός πίνακας).
    * Παράδειγμα: Εισάγετε σε ένα std::vector όλες τις ακέραιες τιμές από το 1 μέχρι και το 10. Διανύστε το διάνυσμα και αυξήστε την τιμή κάθε στοιχείου κατά 1. Εμφανίστε με range based for το περιεχόμενο του διανύσματος σε μια γραμμή.
    * [vector1.cpp](./../recitation/vector1.cpp) 
  * [std::array](https://hackingcpp.com/cpp/std/sequence_containers.html#array). Πίνακας σταθερού μεγέθους.
    * Παράδειγμα: Μεταφέρετε τα στοιχεία ενός πίνακα 10 θέσεων ακεραίων σε ένα std::array. Αλλάξτε τις τιμές κάθε θέσης του array έτσι ώστε να συσσωρεύουν το άθροισμα από όλες τις προηγούμενες θέσεις. Εμφανίστε το περιεχόμενο του array.
    * [array1.cpp](./../recitation/array1.cpp)
  * [std::list](https://hackingcpp.com/cpp/std/sequence_containers.html#list). Διπλά συνδεδεμένη λίστα.
    * Παράδειγμα: Για όλες τις ακέραιες τιμές από το 1 μέχρι και το 20 εισάγετε τις τιμές εναλλάξ την μια στην αρχή και την άλλη στο τέλος ενός std::list. Εμφανίστε τη λίστα.
    * [list1.cpp](./../recitation/list1.cpp)
  * [std::set](https://hackingcpp.com/cpp/std/associative_containers.html). Σύνολο, δεν έχει διπλότυπα, διατηρεί τα στοιχεία του ταξινομημένα.
    * Παράδειγμα: Εισάγετε 10 ακέραιες τιμές σε ένα std::set. Εμφανίστε ταξινομημένες τις τιμές. Πόσες τιμές εμφανίζονται;
    * [set1.cpp](./../recitation/set1.cpp)
  * [std::map](https://hackingcpp.com/cpp/std/associative_containers.html). Πίνακας αντιστοίχισης, διατηρεί ζεύγη της μορφής κλειδί-τιμή, τα ζεύγη είναι ταξινομημένα με βάση το κλειδί.
    * Παράδειγμα: Χρησιμοποιώντας ένα std::map μετρήστε το πλήθος των ψηφίων που υπάρχουν σε όλους τους ακέραιους αριθμούς από το 1 μέχρι το 10000000. Εμφανίστε το πλήθος των παρατηρήσεων κάθε ψηφίου.
    * [map1.cpp](./../recitation/map1.cpp)
* [Iterators](https://hackingcpp.com/cpp/std/iterators_intro.html) (επαναλήπτες). Οι επαναλήπτες επιτρέπουν τη διάσχιση ενός container.
  * random_iterator (τυχαίος επαναλήπτης, έχει δυνατότητα γρήγορης μεταφοράς σε  στοιχείο container με βάση τον αριθμό του δείκτη του στοιχείου)
    * Παράδειγμα: Εισάγετε σε ένα std::vector ακεραίων 10 τιμές. Διανύστε με random iterator το διάνυσμα αυξάνοντας την τιμή κάθε στοιχείου του κατά 1. Εμφανίστε το διάνυσμα.
    * [random_iterator1.cpp](./../recitation/random_iterator1.cpp)
    * [random_iterator2.cpp](./../recitation/random_iterator2.cpp)
  * forward_iterator (επαναλήπτης με δυνατότητα μετακίνησης μόνο προς τα εμπρός)
    * Παράδειγμα: Εισάγετε σε ένα std::list ακεραίων 10 τιμές. Διανύστε τη λίστα με forward iterator διαγράφοντας όλες τις άρτιες τιμές. Εμφανίστε τη λίστα.
    * [forward_iterator1.cpp](./../recitation/forward_iterator1.cpp)
* [Algorithms](https://hackingcpp.com/cpp/std/algorithms/intro.html) (αλγόριθμοι). [Λίστα αλγορίθμων της STL](https://hackingcpp.com/cpp/std/algorithms.html).
  * [std::sort](https://hackingcpp.com/cpp/std/algorithms/reordering.html#sort)
    * Παράδειγμα: Εισάγετε 10 ακέραιες τιμές σε ένα std::vector. Εμφανίστε το άθροισμα των 5 μεγαλύτερων τιμών.
    * [sort1.cpp](./../recitation/sort1.cpp)
  * [std::find](https://hackingcpp.com/cpp/std/algorithms/finding.html)
    * Παράδειγμα: Εισάγετε 10 ακέραιες τιμές σε ένα std::vector. Εξετάστε αν το ακέραιο μέρος του μέσου όρου των τιμών υπάρχει στο std::vector.
    * [find1.cpp](./../recitation/find1.cpp)
  * [std::copy](https://hackingcpp.com/cpp/std/algorithms/copying.html)
    * Παράδειγμα: Εισάγετε 10 ακέραιες τιμές σε ένα std::vector. Αντιγράψτε τις 5 πρώτες τιμές σε ένα άλλο std::vector.
    * [copy1.cpp](./../recitation/copy1.cpp)
  * [std::count_if](https://hackingcpp.com/cpp/std/algorithms.html#count_if)
    * Παράδειγμα: Εισάγετε 10 ακέραιες τιμές σε ένα std::vector. Μετρήστε τις άρτιες τιμές.
    * [count_if1.cpp](./../recitation/count_if1.cpp)
  * [std::accumulate](https://hackingcpp.com/cpp/std/algorithms/numeric.html#accumulate)
    * Παράδειγμα: Εισάγετε 10 ακέραιες τιμές σε ένα std::vector. Υπολογίστε το άθροισμα και το γινόμενο των στοιχείων χωρίς να γράψετε εντολή επανάληψης.
    * [accumulate1.cpp](./../recitation/accumulate1.cpp)

## Εργαστήριο 7 

Επανάληψη

---

## Εργαστηριακές ασκήσεις

### Άσκηση 1

* Κατασκευάστε μια κλάση με όνομα cargo (φορτίο) με μέλη δεδομένων τα ακόλουθα: 
  * id (αναγνωριστικός αριθμός φορτίου) τύπου int.
  * destination (προορισμός) τύπου string.
  * weight (βάρος) τύπου double.
  * fragile (εύθραυστο) τύπου bool.
* Δημιουργήστε προκαθορισμένο κατασκευαστή που να δίνει τις εξής τιμές: 0, "Undefined", 0, false.
* Δημιουργήστε έναν κατασκευαστή που να θέτει όλα τα μέλη δεδομένων σε τιμές που θα δέχεται ως παραμέτρους.
* Δημιουργήστε getters και setters μόνο το πεδίο weight.
* Δημιουργήστε μια συνάρτηση show() που να εμφανίζει τις τιμές όλων των πεδίων του αντικειμένου.
* Δημιουργήστε μια συνάρτηση μέλος make_safe() που εφόσον ένα φορτίο δεν είναι fragile να το κάνει και να αυξάνει το βάρος του κατά 5 κιλά (για υλικά συσκευασίας).
* Στη main:
  * Εισάγετε σε έναν πίνακα 5 θέσεων αντικείμενα cargo ως εξής:
    * 1, Patras, 1000, false
    * 2, Athens, 200, true
    * 3, Kalamata, 2000, false
    * 4, Patras, 1500, true
    * 5, Athens, 1100, false
  * Με μια επανάληψη πραγματοποιήστε κλήση της make_safe για όλα τα αντικείμενα.
  * Εμφανίστε όλα τα αντικείμενα.

**Λύση άσκησης 1**

* [cargo_example.cpp](./../lab2020/lab_ex1/cargo_example.cpp)

**Επιπλέον ερωτήματα άσκησης 1**

* Υπερφορτώστε τον τελεστή << έτσι ώστε να μπορεί να χρησιμοποιηθεί με το cout και να εμφανίζει τις τιμές όλων των πεδίων του αντικειμένου.
* Υπερφορτώστε τον τελεστή == έτσι ώστε να επιστρέφει true αν όλα τα πεδία δεδομένων των αντικειμένων είναι ίδια.
* Υπερφορτώστε τον τελεστή < έτσι ώστε να διατάσσει αντικείμενα cargo με βάση το βάρος τους (σε αύξουσα σειρά).
* Υπερφορτώστε και τους άλλους συγκριτικούς τελεστές.
* Ταξινομήστε τον πίνακα των αντικειμένων (χρησιμοποιήστε την STL συνάρτηση sort).
* Προσθέστε στατική μεταβλητή count που  να καταμετρά το πλήθος των αντικειμένων που δημιουργούνται. Εμφανίστε την τιμή της count στο τέλος της main.
* Διασπάστε τον κώδικα στα αρχεία cargo.hpp, cargo.cpp, driver.cpp. Μεταγλωττίστε τον κώδικα και εκτελέστε τον.
* Προσθέστε unit tests με το catch2 έτσι ώστε να ελέγχεται η ορθή υλοποίηση της συνάρτησης make_safe(). Δημιουργήστε για το λόγο αυτό το αρχείο tests.cpp.

**Λύση επιπλέον ερωτημάτων άσκησης 1**

* [cargo.hpp](./../lab2020/lab_ex1_sol/cargo.hpp)
* [cargo.cpp](./../lab2020/lab_ex1_sol/cargo.cpp)
* [driver.cpp](./../lab2020/lab_ex1_sol/driver.cpp)
* [tests.cpp](./../lab2020/lab_ex1_sol/tests.cpp)
* [catch.hpp](./../lab2020/catch.hpp) θα πρέπει να υπάρχει το catch.hpp στην κατάλληλη θέση