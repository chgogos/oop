# ΕΡΓΑΣΤΗΡΙΟ ΧΕΙΜΕΡΙΝΟΥ ΕΞΑΜΗΝΟΥ 2021-2022

Η διδασκαλία των εργαστηρίων γίνεται δια ζώσης. Η διάρκεια κάθε εργαστηρίου είναι 2 ώρες και κάθε ΟΜΑΔΑ προσέρχεται ανά δύο εβδομάδες στο εργαστήριο. 

**Ομάδες εργαστηρίων**

* Δευτέρα 3-5 (ΟΜΑΔΑ 1 - εργαστήριο Ε4) 11/10/2021, 25/10/2021, ...
* Δευτέρα 3-5 (ΟΜΑΔΑ 2 - εργαστήριο Ε4) 18/10/2021, 01/11/2021, ...
* Δευτέρα 5-7 (ΟΜΑΔΑ 3 - εργαστήριο Ε4) 11/10/2021, 25/10/2021, ...
* Δευτέρα 5-7 (ΟΜΑΔΑ 4 - εργαστήριο Ε4) 18/10/2021, 01/11/2021, ...
* Πέμπτη 2-4 (ΟΜΑΔΑ 5 - εργαστήριο Ε5)  14/10/2021, ~~28/10/2021~~, ...
* Πέμπτη 2-4 (ΟΜΑΔΑ 6 - εργαστήριο Ε5) 21/10/2021, 04/11/2021, ...
* Παρασκευή 4-6 (ΟΜΑΔΑ 7 - εργαστήριο Ε5) 15/10/2021, 29/10/2021, ...
* Παρασκευή 4-6 (ΟΜΑΔΑ 8 - εργαστήριο Ε5) 22/10/2021, 05/11/2021, ...

## Εργαστήριο 1 (11/10/2021 - 22/10/2021)

* Εγκατάσταση και ρύθμιση περιβάλλοντος ανάπτυξης εφαρμογών σε C++
  * GCC compiler για Windows [TDM-GCC](https://jmeubank.github.io/tdm-gcc/)
  * Επεξεργαστής κειμένου [Visual Studio Code](https://code.visualstudio.com/) (VS Code)
  * Extensions για το VS Code για C++
    * [ms-vscode.cpptools](https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools)
    * [formulahendry.code-runner](https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner)
* Συγγραφή προγραμμάτων σε C++, μεταγλώττιση και εκτέλεση από το VS Code
  * [hello1.cpp](./../cpp_playground/ex001/hello1.cpp)
  * [hello2.cpp](./../cpp_playground/ex001/hello2.cpp)
  * [hello3.cpp](./../cpp_playground/ex001/hello3.cpp)
* Μεταγλώττιση και εκτέλεση προγραμμάτων από τη γραμμή εντολών
  * τα switches -c, -o, -g, -O2, -Wall, -Werror, -std (c++98, c++03, c++11, c++14, c++17, c++20, ...)
    * [source.cpp](./lab01/source.cpp) για παραδείγματα μεταγλώττισης με -c, -o, -g, -O2
    * [warning_examples.cpp](./lab01/warning_examples.cpp) για παραδείγματα μεταγλώττισης με -Wall, -Werror
    * [std_examples.cpp](./lab01/std_examples.cpp) για παραδείγματα μεταγλώττισης με -std=c++98, -std=c++11
* Αποσφαλμάτωση κώδικα (debugging)
  * Χρήση του Run & Debug του VS Code (βηματική εκτέλεση, breakpoints, watches ...)
  * [Παραδείγματα debugging](../various/DEBUG_EXAMPLES/README.md)
* Διαχωρισμός header / source αρχείων
  * [numbers.hpp](./../cpp_playground/ex110/numbers.hpp)
  * [numbers.cpp](./../cpp_playground/ex110/numbers.cpp)
  * [main.cpp](./../cpp_playground/ex110/main.cpp)
  * Μεταγλώττιση και εκτέλεση
    ```
    > g++ numbers.cpp main.cpp -o main
    > main.exe
    GCD of 30 and 12 is 6
    LCM of 30 and 12 is 60
    ```
* Συναρτήσεις, πέρασμα με τιμή, πέρασμα με αναφορά
  * [calls.cpp](./../cpp_playground/ex001/calls.cpp)
  * Παράδειγμα: Γράψτε μια συνάρτηση που να δέχεται τις πλευρές ενός ορθογωνίου παραλληλογράμμου και να επιστρέφει την περίμετρο και το εμβαδόν του μέσω των παραμέτρων της. Καλέστε τη συνάρτηση από το κύριο πρόγραμμα.
    * [call_by_ref_example.cpp](./lab01/call_by_ref_example.cpp)
* Ο ρόλος των στατικών μεταβλητών σε συναρτήσεις
  * [static1.c](./../cpp_playground/ex013/static1.c)
  * [static2.cpp](./../cpp_playground/ex013/static2.cpp)
* Η βιβλιοθήκη Catch2 για συγγραφή ελέγχων
  * [Παραδείγματα](../catch2_examples/README.md) 

## Εργαστήριο 2 (25/10/2021 - 5/11/2021)

* Δομές (structs) - εγγραφές. Παράδειγμα: Ζητείται η δημιουργία μιας δομής circle με τα πεδία center_x, center_y για τις συντεταγμένες του κέντρου του κύκλου και το πεδίο radius για την ακτίνα του κύκλου. Προσθέστε συναρτήσεις για τον υπολογισμό του εμβαδού και της περιμέτρου ενός κύκλου. Προσθέστε μια συνάρτηση που να ελέγχει αν ένα σημείο βρίσκεται εντός ή εκτός ενός κύκλου. Συμπληρώστε στη main κώδικα που να δημιουργεί εγγραφές και να καλεί τις ανωτέρω συναρτήσεις.
  * [struct_circle_example.cpp](./lab02/struct_circle_example.cpp)
* Κλάσεις - αντικείμενα. Παράδειγμα: Ζητείται η δημιουργία μιας κλάσης circle με ιδιωτικά μέλη δεδομένων center_x, center_y για τις συντεταγμένες του κέντρου του κύκλου και το ιδιωτικό μέλος δεδομένων radius για την ακτίνα του κύκλου. Συμπληρώστε 2 constructors και τον destructor έτσι ώστε να εμφανίζονται μηνύματα όταν δημιουργείται και όταν καταστρέφεται ένα αντικείμενο.Προσθέστε συναρτήσεις μέλη για τον υπολογισμό του εμβαδού και της περιμέτρου του κύκλου. Προσθέστε μια συνάρτηση μέλος που να ελέγχει αν ένα σημείο βρίσκεται εντός ή εκτός του κύκλου. Συμπληρώστε στη main κώδικα που να δημιουργεί αντικείμενα και να καλεί τις ανωτέρω συναρτήσεις.
  * [class_circle_example.cpp](./lab02/class_circle_example.cpp)
* Δημόσια, ιδιωτική πρόσβαση (ενθυλάκωση). Παράδειγμα: Γράψτε ένα πρόγραμμα που να ορίζει μια κλάση Α με ένα ακέραιο ιδιωτικό μέλος δεδομένων x και ένα ακέραιο δημόσιο μέλος δεδομένων y. Συμπληρώστε τον απαιτούμενο κώδικα sto [protection_levels_example.cpp](./lab02/protection_levels_example.cpp) έτσι ώστε για ένα αντικείμενο που δημιουργείται στη main να εμφανίζεται τόσο η τιμή του x όσο και η τιμή του y.
  * [protection_levels_example_sol.cpp](./lab02/protection_levels_example_sol.cpp)
* Κατασκευαστές. Παράδειγμα: Γράψτε ένα πρόγραμμα που να ορίζει μια κλάση Α με δύο ακέραια ιδιωτικά μέλη δεδομένων x και y. Ορίστε 2 διαφορετικούς κατασκευαστές κάνοντας χρήση και προκαθορισμένης τιμής για την παράμετρο ενός κατασκευαστή. Στη main δημιουργείστε 1 αντικείμενο με τον προκαθορισμένο κατασκευαστή και 1 πίνακα 5 αντικειμένων με το δεύτερο κατασκευαστή.
  * [constructors_example.cpp](./lab02/constructors_example.cpp) 
* Καταστροφείς. Παράδειγμα: Ορίστε τον καταστροφέα μιας κλάσης έτσι ώστε να εμφανίζει τη θέση μνήμης του αντικειμένου και το μέγεθος του αντικειμένου που καταστρέφεται. Στη main προκαλέστε διαδοχικά για 10 φορές σε μια for την κλήση του καταστροφέα.
  * [destructor_example.cpp](./lab02/destructor_example.cpp)
* Συναρτήσεις μέλη. Παράδειγμα: Έστω μια κλάση Α που περιέχει μια ιδιωτική συνάρτηση fun που δέχεται μια ακέραια παράμετρο την οποία και εμφανίζει [member_functions_example.cpp](./lab02/member_functions_example.cpp). Προσθέστε τον κατάλληλο κώδικα έτσι ώστε στη main να εμφανίζεται το αποτέλεσμα της κλήσης της συνάρτησης fun.
  * [member_functions_example_sol.cpp](./lab02/member_functions_example_sol.cpp)
* Φίλες συναρτήσεις. Παράδειγμα: Δημιουργήστε μια κλάση Α με ένα ακέραιο ιδιωτικό μέλος x. Συμπληρώστε μια φίλη συνάρτηση fun που να εκτυπώνει την τιμή του x για ένα αντικείμενο της κλάσης Α.
  * [friend_function_example.cpp](./lab02/friend_function_example.cpp)
* Η βιβλιοθήκη [fmt](https://fmt.dev/latest/index.html) για εύκολη εμφάνιση αποτελεσμάτων
  * [fmt_example1.cpp](./lab02/fmt_example1.cpp)
  * [Usage](https://fmt.dev/latest/usage.html) δημιουργία φακέλου fmt στον φάκελο που βρίσκεται το fmt_example1.cpp, αντιγραφή των core.h, format-inl.h, format.h από το zip του fmt στον φάκελο fmt, αντιγραφή του format.cc από το zip του fmt στον ίδιο φάκελο με το fmt_example1.cpp 

Μεταγλώττιση και εκτέλεση του fmt_example1.cpp

```cmd
$ g++ fmt_example1.cpp format.cc -ο fmt_example1 -std=c++11
$ fmt_example1.exe
The answer is 42.
Elapsed time: 1.23 seconds
Don't panic!
Elapsed time: 1.23 seconds
```

## Εργαστήριο 3

* Υπερφόρτωση (overload) συναρτήσεων. Παράδειγμα: Γράψτε κώδικα που να πραγματοποιεί υπερφόρτωση σε μια συνάρτηση με όνομα fun έτσι ώστε να υπάρχουν 3 εκδόσεις της, μια που να δέχεται 1 int παράμετρο, μια που να δέχεται 1 double παράμετρο και μια που να δέχεται 1 int και 1 double πράμετρο. Κάθε συνάρτηση, απλά να εμφανίζει τις τιμές των παραμέτρων της. Καλέστε και τις 3 συναρτήσεις από το κύριο πρόγραμμα. Επαναλάβατε το παράδειγμα ορίζοντας τις ανωτέρω συναρτήσεις ως συναρτήσεις μέλη μιας κλάσης A.
  * [function_overload.cpp](./lab03/function_overload.cpp)
  * [member_function_overload.cpp](./lab03/member_function_overload.cpp)
* Υπερφόρτωση τελεστών 
  * Παράδειγμα 1: Δημιουργήστε μια κλάση Α με 3 ακέραια ιδιωτικά μέλη δεδομένων. Υπερφορτώστε τον τελεστή < έτσι ώστε η σύγκριση αντικειμένων να γίνεται με βάση το άθροισμα των 3 ιδιωτικών μελών. Επιπλέον, υπερφορτώστε τον τελεστή << έτσι ώστε να εμφανίζονται τα 3 ιδιωτικά μέλη και το άθροισμά τους.
    * [overload1.cpp](./../recitation/overload1.cpp)
  * Παράδειγμα 2: Δημιουργήστε μια κλάση customer με 2 ιδιωτικά μέλη δεδομένων name και balance (υπόλοιπο λογαριασμού). Υπερφορτώστε τους τελεστές < και == για τα αντικείμενα customer έτσι ώστε η σύγκριση μεταξύ τους να γίνεται με βάση το υπόλοιπο του λογαριασμού. Στο κύριο πρόγραμμα δημιουργήστε αντικείμενα customer και χρησιμοποιήστε τους τελεστές < και ==.
    * [operator_overload4.cpp](./../cpp_playground/ex015/operator_overload4.cpp)
* Δείκτες, δέσμευση και αποδέσμευση μνήμης με new και delete
  * Παράδειγμα 1: Γράψτε μια συνάρτηση που να δέχεται 4 ακέραιες παραμέτρους. Κατά την κλήση της να επιστρέφει το άθροισμα και το γινόμενο των 2 πρώτων ορισμάτων στο τρίτο και στο τέταρτο όρισμα αντίστοιχα. Να χρησιμοποιηθούν δείκτες για την επιστροφή των τιμών. 
    * [pass_by_ref_using_pointers.cpp](./lab03/pass_by_ref_using_pointers.cpp)
  * Παράδειγμα 2: Γράψτε πρόγραμμα που να δεσμεύει θέσεις μνήμης για έναν int, έναν double και έναν char, να αναθέτει μια τιμή σε κάθε δεσμευμένη θέση μνήμης και στη συνέχεια να απελευθερώνει τη μνήμη.
    <!-- * [dynamic_memory1.cpp](./../recitation/dynamic_memory1.cpp) -->
    * [dynamic_memory2.cpp](./../recitation/dynamic_memory2.cpp)
  * Παράδειγμα 3: Το πρόβλημα των dangling pointers
    * [dangling_pointer.cpp](./../cpp_playground/ex001/dangling_pointer.cpp) 
* Πίνακες
  * Παράδειγμα: Γράψτε πρόγραμμα που να δημιουργεί έναν πίνακα 5 θέσεων με τις τιμές {2,7,1,3,6}. Να δέχεται από τον χρήστη μια ακέραια τιμή x και να αντιγράφει τον πίνακα x φορές σε έναν δυναμικό πίνακα τον οποίο στην συνέχεια να εμφανίζει στην οθόνη. Να αποδεσμεύει τον πίνακα πριν τον τερματισμό του προγράμματος
    <!-- * [static_dynamic_arrays1.cpp](./../recitation/static_dynamic_arrays1.cpp) -->
    * [static_dynamic_arrays2.cpp](./../recitation/static_dynamic_arrays2.cpp)
* Πολυδιάστατοι πίνακες
  * Παράδειγμα 1: Γράψτε πρόγραμμα που να δημιουργεί έναν πίνακα 5x5 που σε κάθε στοιχείο του να έχει ως τιμή το άθροισμα των δεικτών του στοιχείου (π.χ. στο στοιχείο a[2][3] να έχει την τιμή 2+3=5). Εμφανίστε τον πίνακα.
    * [two_dimensional_array1.cpp](./../recitation/two_dimensional_array1.cpp)
  * Παράδειγμα 2: Γράψτε συνάρτηση που να δέχεται ως παραμέτρους έναν δισδιάστατο πίνακα ακεραίων, τον αριθμό γραμμών και τον αριθμό στηλών του και να εμφανίζει τα περιεχόμενα του πίνακα. Καλέστε από το κύριο πρόγραμμα τη συνάρτηση για έναν δυναμικό πίνακα.
    * [matrix2b.cpp](./../cpp_playground/ex001/matrix2b.cpp)
* Κατασκευαστής αντιγραφής (copy constructor) που πραγματοποιεί αντιγραφή σε βάθος (deep copy)
  * Παράδειγμα: Γράψτε ένα πρόγραμμα που να ορίζει μια κλάση Α με ένα ιδιωτικό μέλος δεδομένων που να είναι δείκτης προς πίνακα ακεραίων. Συμπληρώστε έναν κατασκευαστή αντιγραφής που να πραγματοποιεί deep copy στα δεδομένα του πίνακα. Χρησιμοποιήστε τον κατασκευαστή αντιγραφής στη main.
    * [deep_copy1.cpp](./../recitation/deep_copy1.cpp)


## Εργαστήριο 4

* Κληρονομικότητα
* Παράκαμψη (override)
* Πολυμορφισμός - ιδεατές συναρτήσεις
* Στατικές μεταβλητές κλάσεων

## Εργαστήριο 5

* Χειρισμός εξαιρέσεων
* Ανάγνωση δεδομένων από αρχεία 
* Εγγραφή δεδομένων σε αρχεία
* Διαμέριση κώδικα σε πολλαπλά αρχεία κώδικα και κεφαλίδων, μεταγλώττιση

## Εργαστήριο 6

* Πρότυπα (συναρτήσεις, κλάσεις)
* Λάμδα συναρτήσεις
* Δείκτες συνάρτησης

## Εργαστήριο 7

* STL
    * Containers
    * Iterators
    * Algorithms

---

## Εργαστηριακές ασκήσεις

### Άσκηση 1

* Κατασκευάστε μια κλάση με όνομα cargo (φορτίο) με μέλη δεδομένων τα ακόλουθα: 
  * id (αναγνωριστικός αριθμός φορτίου) τύπου int.
  * destination (προορισμός) τύπου string.
  * weight (βάρος) τύπου double.
  * fragile (εύθραυστο) τύπου bool.
* Δημιουργήστε προκαθορισμένο κατασκευαστή που να δίνει τις εξής τιμές: 0, "Undefined", 0, false.
* Δημιουργήστε έναν κατασκευαστή που να θέτει όλα τα μέλη δεδομένων σε τιμές που θα δέχεται ως παραμέτρους.
* Δημιουργήστε getters και setters μόνο το πεδίο weight.
* Δημιουργήστε μια συνάρτηση show() που να εμφανίζει τις τιμές όλων των πεδίων του αντικειμένου.
* Δημιουργήστε μια συνάρτηση μέλος make_safe() που εφόσον ένα φορτίο δεν είναι fragile να το κάνει και να αυξάνει το βάρος του κατά 5 κιλά (για υλικά συσκευασίας).
* Στη main:
  * Εισάγετε σε έναν πίνακα 5 θέσεων αντικείμενα cargo ως εξής:
    * 1, Patras, 1000, false
    * 2, Athens, 200, true
    * 3, Kalamata, 2000, false
    * 4, Patras, 1500, true
    * 5, Athens, 1100, false
  * Με μια επανάληψη πραγματοποιήστε κλήση της make_safe για όλα τα αντικείμενα.
  * Εμφανίστε όλα τα αντικείμενα.

**Λύση άσκησης 1**

* [cargo_example.cpp](./../lab2020/lab_ex1/cargo_example.cpp)

**Επιπλέον ερωτήματα άσκησης 1**

* Υπερφορτώστε τον τελεστή << έτσι ώστε να μπορεί να χρησιμοποιηθεί με το cout και να εμφανίζει τις τιμές όλων των πεδίων του αντικειμένου.
* Υπερφορτώστε τον τελεστή == έτσι ώστε να επιστρέφει true αν όλα τα πεδία δεδομένων των αντικειμένων είναι ίδια.
* Υπερφορτώστε τον τελεστή < έτσι ώστε να διατάσσει αντικείμενα cargo με βάση το βάρος τους (σε αύξουσα σειρά).
* Υπερφορτώστε και τους άλλους συγκριτικούς τελεστές.
* Ταξινομήστε τον πίνακα των αντικειμένων (χρησιμοποιήστε την STL συνάρτηση sort).
* Προσθέστε στατική μεταβλητή count που  να καταμετρά το πλήθος των αντικειμένων που δημιουργούνται. Εμφανίστε την τιμή της count στο τέλος της main.
* Διασπάστε τον κώδικα στα αρχεία cargo.hpp, cargo.cpp, driver.cpp. Μεταγλωττίστε τον κώδικα και εκτελέστε τον.
* Προσθέστε unit tests με το catch2 έτσι ώστε να ελέγχεται η ορθή υλοποίηση της συνάρτησης make_safe(). Δημιουργήστε για το λόγο αυτό το αρχείο tests.cpp.

**Λύση επιπλέον ερωτημάτων άσκησης 1**

* [cargo.hpp](./../lab2020/lab_ex1_sol/cargo.hpp)
* [cargo.cpp](./../lab2020/lab_ex1_sol/cargo.cpp)
* [driver.cpp](./../lab2020/lab_ex1_sol/driver.cpp)
* [tests.cpp](./../lab2020/lab_ex1_sol/tests.cpp)
* [catch.hpp](./../lab2020/catch.hpp) θα πρέπει να υπάρχει το catch.hpp στην κατάλληλη θέση

### Άσκηση 2

Χρησιμοποιήστε τη γλώσσα C++ για να υλοποιήσετε μια έκδοση του παιχνιδιού “rock paper scissors” που να εκτελείται από τη γραμμή εντολών και στην οποία οι αντίπαλοι να είναι ο χρήστης του προγράμματος και ο υπολογιστής.  Ένας αγώνας θα έχει 7 γύρους και σε κάθε γύρο θα ζητείται από το χρήστη να εισάγει την επιλογή του που θα μπορεί να είναι R ή P ή S για rock, paper ή scissors αντίστοιχα. O υπολογιστής θα πραγματοποιεί τυχαία επιλογή και ο γύρος θα τελειώνει όταν θα υπάρχει νικητής, ο οποίος και θα εμφανίζεται στην οθόνη (USER ή MACHINE). Στο τέλος των 7 γύρων θα εμφανίζεται ο νικητής και το σκορ.

**Λύση άσκησης 2**

* [rock_paper_scissors.cpp](./../lab2020-2021/lab2020f_ex1_sol/rock_paper_scissors.cpp)

