# ΕΡΓΑΣΤΗΡΙΟ ΧΕΙΜΕΡΙΝΟΥ ΕΞΑΜΗΝΟΥ 2020-2021

## Λίστα εργαστηρίων

### C++

* [Εργαστήριο 1](./lab01/) Δομές (structs), κλάσεις (classes), αντικείμενα (objects), επίπεδα προστασίας (public, private), κατασκευαστές (constructors), καταστροφείς (destructors)
* [Εργαστήριο 2](./lab02/) Δείκτες (pointers), αναφορές (references), πέρασμα με τιμή (pass by  value), πέρασμα με αναφορά (pass by reference), υπερφόρτωση συναρτήσεων (overload), υπερφόρτωση τελεστών (operator overload)
* [Εργαστήριο 3](./lab03/) Κληρονομικότητα (inheritance), παράκαμψη (override), διαμέριση κώδικα σε αρχεία κεφαλίδων και αρχεία κώδικα (code partitioning)
* [Εργαστήριο 4](./lab04/) Πρότυπα (templates), STL (Standard Template Library) 

### Java

* [Εργαστήριο 5](./lab05/) Κλάσεις (classes), αντικείμενα (objects), επίπεδα προστασίας (public, package, private), κληρονομικότητα (inheritance)
* [Εργαστήριο 6](./lab06/) Διεπαφές (interfaces), παραμετρικοί τύποι (Generics), συλλογές της Java (Java Collections) 

---

## Εργαστηριακές ασκήσεις 2020-2021

### Άσκηση 1: Rock paper scissors (Πέτρα Χαρτί Ψαλίδι) 

Παράδοση στο [ecourse](http://ecourse.uoi.gr/course/view.php?id=1944) μέχρι τις **23/10/2020**.

Χρησιμοποιήστε αντικειμενοστραφή προγραμματισμό με τη γλώσσα C++ για να υλοποιήσετε μια έκδοση του παιχνιδιού ["rock paper scissors"](https://en.wikipedia.org/wiki/Rock_paper_scissors) που να εκτελείται από τη γραμμή εντολών και στην οποία οι αντίπαλοι να είναι ο χρήστης του προγράμματος και ο υπολογιστής.  Ένας αγώνας θα έχει 7 γύρους και σε κάθε γύρο θα ζητείται από το χρήστη να εισάγει την επιλογή του που θα μπορεί να είναι R ή P ή S για rock, paper ή scissors αντίστοιχα. O υπολογιστής θα πραγματοποιεί τυχαία επιλογή και ο γύρος θα τελειώνει όταν θα υπάρχει νικητής, ο οποίος και θα εμφανίζεται στην οθόνη (USER ή MACHINE). Στο τέλος των 7 γύρων θα εμφανίζεται ο νικητής και το σκορ.

### Άσκηση 2

Θα ανακοινωθεί.

### Άσκηση 3

Θα ανακοινωθεί.

---


## Λυμένες εργαστηριακές ασκήσεις

### Άσκηση 1

* Κατασκευάστε μια κλάση με όνομα cargo (φορτίο) με μέλη δεδομένων τα ακόλουθα: 
  * id (αναγνωριστικός αριθμός φορτίου) τύπου int.
  * destination (προορισμός) τύπου string.
  * weight (βάρος) τύπου double.
  * fragile (εύθραυστο) τύπου bool.
* Δημιουργήστε προκαθορισμένο κατασκευαστή που να δίνει τις εξής τιμές: 0, "Undefined", 0, false.
* Δημιουργήστε έναν κατασκευαστή που να θέτει όλα τα μέλη δεδομένων σε τιμές που θα δέχεται ως παραμέτρους.
* Δημιουργήστε getters και setters μόνο το πεδίο weight.
* Δημιουργήστε μια συνάρτηση show() που να εμφανίζει τις τιμές όλων των πεδίων του αντικειμένου.
* Δημιουργήστε μια συνάρτηση μέλος make_safe() που εφόσον ένα φορτίο δεν είναι fragile να το κάνει και να αυξάνει το βάρος του κατά 5 κιλά (για υλικά συσκευασίας).
* Στη main:
  * Εισάγετε σε έναν πίνακα 5 θέσεων αντικείμενα cargo ως εξής:
    * 1, Patras, 1000, false
    * 2, Athens, 200, true
    * 3, Kalamata, 2000, false
    * 4, Patras, 1500, true
    * 5, Athens, 1100, false
  * Με μια επανάληψη πραγματοποιήστε κλήση της make_safe για όλα τα αντικείμενα.
  * Εμφανίστε όλα τα αντικείμενα.

#### Λύση άσκησης 1

* [cargo_example.cpp](./lab_ex1/cargo_example.cpp)

#### Επιπλέον ερωτήματα άσκησης 1

* Υπερφορτώστε τον τελεστή << έτσι ώστε να μπορεί να χρησιμοποιηθεί με το cout και να εμφανίζει τις τιμές όλων των πεδίων του αντικειμένου.
* Υπερφορτώστε τον τελεστή == έτσι ώστε να επιστρέφει true αν όλα τα πεδία δεδομένων των αντικειμένων είναι ίδια.
* Υπερφορτώστε τον τελεστή < έτσι ώστε να διατάσσει αντικείμενα cargo με βάση το βάρος τους (σε αύξουσα σειρά).
* Υπερφορτώστε και τους άλλους συγκριτικούς τελεστές.
* Ταξινομήστε τον πίνακα των αντικειμένων (χρησιμοποιήστε την STL συνάρτηση sort).
* Προσθέστε στατική μεταβλητή count που  να καταμετρά το πλήθος των αντικειμένων που δημιουργούνται. Εμφανίστε την τιμή της count στο τέλος της main.
* Διασπάστε τον κώδικα στα αρχεία cargo.hpp, cargo.cpp, driver.cpp. Μεταγλωττίστε τον κώδικα και εκτελέστε τον.
* Προσθέστε unit tests με το catch2 έτσι ώστε να ελέγχεται η ορθή υλοποίηση της συνάρτησης make_safe(). Δημιουργήστε για το λόγο αυτό το αρχείο tests.cpp.
<!-- * Χρησιμοποιήστε τη βιβλιοθήκη fmt για εμφάνιση αποτελεσμάτων στην οθόνη. -->

#### Λύση επιπλέον ερωτημάτων άσκησης 1

* [cargo.hpp](./lab_ex1_sol/cargo.hpp)
* [cargo.cpp](./lab_ex1_sol/cargo.cpp)
* [driver.cpp](./lab_ex1_sol/driver.cpp)
* [tests.cpp](./lab_ex1_sol/tests.cpp)
* [catch.hpp](./catch.hpp) θα πρέπει να υπάρχει το catch.hpp στην κατάλληλη θέση


### Άσκηση 2

Δημιουργήστε ένα πρόγραμμα που να υπολογίζει την ημερομηνία και την ημέρα της εβδομάδας για το ημερολογιακό έτος 2020. Για το σκοπό αυτό θα κατασκευαστεί η κλάση date2020.

* Συμπληρώστε την κλάση date2020 στα δύο αρχεία date2020.hpp και date2020.cpp. Η κλάση έχει δύο int ιδιωτικά μέλη δεδομένων d για την ημέρα και m  για τον μήνα. Αν η ημερομηνία δεν είναι έγκυρη ημερομηνία του 2020 τότε να θέτει m=-1 και d=-1. Υλοποίηστε την ακόλουθη διεπαφή για την κλάση  date2020:
  * date2020();
    * O προκαθορισμένος κατασκευαστής date2020() θα θέτει ως ημερομηνία 1 January 2020.
  * date2020(int d, int m);
    * Ο κατασκευαστής date2020(int d, int m) θα δέχεται ημέρα και μήνα και θα θέτει την ημερομηνία κατάλληλα.
  * void plus_days(int days);
    * Η συνάρτηση plus_days(int days) θα προσθέτει days ημέρες στην τρέχουσα ημερομηνία.
  * date2020(int d);
    * Ο κατασκευαστής date2020(int d) θα δέχεται τιμές από το 1 μέχρι και το 366 και θα θέτει την ημερομηνία ως την ημερομηνία d μέρες από την έναρξη του έτους 2020.
  * string get_day_name();
    * H συνάρτηση get_day_name() θα επιστρέφει το όνομα της ημέρας στο οποίο αντιστοιχεί η ημερομηνία.
  * void print(); (έχει ήδη υλοποιηθεί)
    * Η συνάρτηση print() θα εκτυπώνει την ημερομηνία όπως στο παράδειγμα που ακολουθεί: 15 March 2020 - (Sunday - 75).
  * int get_days_in_year(); (έχει ήδη υλοποιηθεί)
    * Η συνάρτηση get_days_in_year() θα επιστρέφει το πλήθος των ημερών από την αρχή τους έτους στο οποίο αντιστοιχεί η ημερομηνία.
* Εκτελέστε το πρόγραμμα οδηγό main.cpp και καταγράψτε την έξοδό του σε ένα αρχείο με όνομα main.out.
* Εκτελέστε τα unit tests που περιέχονται στο tests.cpp.

#### Αρχεία άσκησης

* [date2020.hpp](./lab_ex2/date2020.hpp)
* [date2020.cpp](./lab_ex2/date2020.cpp)
* [main.cpp](./lab_ex2/main.cpp)
* [tests.cpp](./lab_ex2/tests.cpp) (θα πρέπει να υπάρχει το catch.hpp στην κατάλληλη θέση ..)

Η μεταγλώττιση και η εκτέλεση του προγράμματος γίνεται ως εξής:

```bash
$ g++ date2020.cpp main.cpp -o main -std=c++11
./main

$ g++ date2020.cpp tests.cpp -o tests -std=c++11
./tests
```

#### Λύση άσκησης 2

* [date2020.hpp](./lab_ex2_sol/date2020.hpp)
* [date2020.cpp](./lab_ex2_sol/date2020.cpp)
* [main.cpp](./lab_ex2_sol/main.cpp)
* [tests.cpp](./lab_ex2_sol/tests.cpp) (θα πρέπει να υπάρχει το catch.hpp στην κατάλληλη θέση)

### Άσκηση 3 (1η εργαστηριακή άσκηση 2019-2020)

Η εκφώνηση της άσκησης βρίσκεται στο [20200217_assignment1.pdf](./lab_ex3/20200217_assignment1.pdf)

* Αρχικός κώδικας άσκησης: [account_bank.cpp](./lab_ex3/account_bank.cpp)

#### A' Λύση άσκησης 3

* [account_bank.cpp](./lab_ex3_sol/account_bank.cpp) (θα πρέπει να υπάρχει το catch.hpp στην κατάλληλη θέση)

#### B' Λύση άσκησης 3 (με διαμέριση κώδικα)

* [account_bank.hpp](./lab_ex3_sol2/account_bank.hpp)
* [account_bank.cpp](./lab_ex3_sol2/account_bank.cpp)
* [tests.cpp](./lab_ex3_sol2/tests.cpp) (θα πρέπει να υπάρχει το catch.hpp στην κατάλληλη θέση)
* [readme.txt](./lab_ex3_sol2/readme.txt)
* [makefile](./lab_ex3_sol2/makefile)

---

## Χρήση βιβλιοθηκών στη C++

### Catch2

<https://github.com/catchorg/Catch2>

* [main.cpp](./simple_catch_example/main.cpp)

  ```sh
  g++ main.cpp -std=c++11 -o main
  ./main
  ```

### fmt

### spdlog
